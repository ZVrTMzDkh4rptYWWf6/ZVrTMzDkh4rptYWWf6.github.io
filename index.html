<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MDAC Formatter</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        textarea { width: 100%; height: 200px; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; }
        .editable { background-color: #f0f0f0; }
        button { margin: 10px 0; }
        #configPanel { margin-bottom: 20px; }
        .dropdown { position: relative; display: inline-block; width: 100%; }
        .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1; max-height: 200px; overflow-y: auto; }
        .dropdown-content div { padding: 12px 16px; text-decoration: none; display: block; cursor: pointer; }
        .dropdown-content div:hover, .dropdown-content div.selected { background-color: #f1f1f1; }
        .public-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .see-all { font-size: 0.8em; color: #666; font-style: italic; background-color: #e9e9e9; }
		.trash-icon {
			cursor: pointer;
		}
        #updateNotification {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none;
			z-index: 999;
        }
        #versionDisplay {
            font-size: 0.5em;
            vertical-align: middle;
            margin-left: 10px;
            cursor: pointer;
            position: relative;
            display: inline-block;
        }
        #changelogTooltip {
            position: absolute;
            display: none;
            background-color: #555;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            width: 500px;
            top: 100%;
            left: 50%;
            transform: translateX(-20%);
            z-index: 1;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #versionDisplay:hover #changelogTooltip {
            display: block;
        }
        #changelogTooltip::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 20%;
            transform: translateX(-50%);
            border-width: 0 10px 10px 10px;
            border-style: solid;
            border-color: transparent transparent #555 transparent;
        }
        .status-badge {
            font-size: 0.8em;
            padding: 2px 5px;
            border-radius: 3px;
            color: white;
        }
        .status-valid {
            background-color: #4CAF50;
        }
        .status-error {
            background-color: #F44336;
        }
		.error-row {
			background-color: #ffeecc;
		}
		.error-row td {
			background-color: #ffeecc;
		}
        .error-section {
            background-color: #FFECB3;
            border: 1px solid #FFC107;
            padding: 20px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .error-link {
            display: block;
            color: #D32F2F;
            text-decoration: none;
            margin-bottom: 5px;
        }
        .error-link:hover {
            text-decoration: underline;
        }
        .line-number {
            width: 30px;
            text-align: right;
            color: #888;
            padding-right: 10px;
        }
		.invalid-ip, .invalid-name {
			background-color: #ffcccc !important;
		}
        #processingOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        #processingBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>MDAC Formatter <span id="versionDisplay"></span></h1>
    <div id="versionInfo" data-version="1.4.7"></div>
    <div id="changelogTooltip">
        <h3>Changelog:</h3>
        <ul>
            <li>v1.4.7:<br />- Added safety feature to prevent data loss when you make changes to a table and haven't downloaded the csv yet.</li><br />
            <li>v1.4.6:<br />- Added redo function (ctrl+y or ctrl+shift+z).</li><br />
            <li>v1.4.5:<br />- Improved bug with error handler.<br />- Significantly improved displaying of errors that are found with both Hostname and IP Validation.<br/>- Added enhanced undo function.</li><br />
            <li>v1.4.4:<br />- Added Changelog Display</li><br />
            <li>v1.4.3:<br />- Added version display and changelog</li><br />
            <li>v1.4.2:<br />- Improved error handling</li><br />
            <li>v1.4.1:<br />- Fixed minor bugs</li>
        </ul>
    </div>
    <div id="updateNotification" style="display: none;">
        A new version (v<span id="newVersionNumber"></span>) is available.<br /><br /><a href="javascript:location.reload(true)">Refresh</a> the page to update from v<span id="currentVersionNumber"></span>.
    </div>
    <div id="processingOverlay">
        <div id="processingBox">
            <h3>Processing MDAC</h3>
            <p id="processingStatus">Processing data...</p>
        </div>
    </div>
    <div id="configPanel">
        <label for="dtcModelFrom">DTC Model Change:</label>
        <input type="text" id="dtcModelFrom" value="DTC2022Model">
        <label for="dtcModelTo"> To:</label>
        <input type="text" id="dtcModelTo" value="2022">
        <br/><br />
        <label for="allowBlankIP">Allow empty lvs.hostname:</label>
        <input type="checkbox" id="allowBlankIP" checked>
		<br />
        <label for="igsservicetowerGuess">Guess IGS Service Tower:</label>
        <input type="checkbox" id="igsservicetowerGuess">
		<br />
        <label for="ostypeGuess">Guess OS Type:</label>
        <input type="checkbox" id="ostypeGuess">
        <br />
    </div>
    <textarea id="inputData" placeholder="Paste your MDAC data here..."></textarea>
    <button onclick="processData()">Process Data</button>
	
    <h2 id="addHeading">Add Actions</h2>
    <div id="addErrorSection" class="error-section" style="display: none;"></div>
    <table id="addTable"></table>
    <button id="addDownloadButton" onclick="downloadCSV('add')">Download Add CSV</button>
	
    <hr />
    <h2 id="removeHeading">Remove Actions</h2>
    <div id="removeErrorSection" class="error-section" style="display: none;"></div>
    <table id="removeTable"></table>
    <button id="removeDownloadButton" onclick="downloadCSV('remove')">Download Remove CSV</button>
	
    <hr />
    <h2 id="changeHeading">Change Actions</h2>
    <div id="changeErrorSection" class="error-section" style="display: none;"></div>
    <table id="changeTable"></table>
    <button id="changeDownloadButton" onclick="downloadCSV('change')">Download Change CSV</button>


    <script>

	let debugMode = false; // Set this to true when you need to debug
	const showTimestamp = false; // Set to false if you don't want timestamps in logs
	
	let allow_blank_ip = true;
	
	let undoStack = [];
	let redoStack = [];
	let maxUndoStack = 100; // Maximum number of undos
	
	let addData = [];
	let removeData = [];
	let changeData = [];
	
	let addCount = 0;
	let removeCount = 0;
	let changeCount = 0;
	let errorCount = 0;


	let hasUnsavedChanges = false;
	
	let tableEdited = {
		add: false,
		remove: false,
		change: false
	};

	let csvDownloaded = {
  		add: false,
  		remove: false,
  		change: false
	};

  	const requiredColumns = ['public_Name', 'lvs.hostname', 'lvs.assetfunction', 'lvs.supporthours', 'lvs.assetlocation', 'lvs.managedservicelevel', 'lvs.supportlevel', 'lvs.confidentialityclass', 'lvs.deviceplatform', 'lvs.igdeviceclass', 'lvs.igsservicetower', 'lvs.ostype', 'lvs.igsbackup', 'lvs.patching', 'lvs.pcirole', 'lvs.pcipurpose', 'lvs.dtcmodel', 'lvs.nocdeviceclass', 'lvs.patchgroup'];

  	const dropdownOptions = {
  		'lvs.igsservicetower': ['Citrix', 'Cloud', 'Database', 'Internal Systems', 'Linux', 'Messaging', 'Network', 'Network Voice', 'NOC', 'Server', 'Storage & Backup', 'Virtualization', 'Windows'],
  		'lvs.ostype': ['Network', 'Windows', 'Linux', 'VMware', 'Other', 'NTAP', 'Cisco ASA', 'FortiOS', 'iLO', 'NX-OS', 'Xen'],
  		'lvs.igdeviceclass': ['Citrix ADC', 'Linux Virtualized', 'Windows Virtualized', 'Virtual SQL Server', 'NOC Toolset', 'SOC Toolset', 'Virtual Active Directory', 'Virtual Exchange', 'Physical Host/Blade Chassis', 'Office Firewall', 'Router', 'Edge Switch', 'Core Switch', 'Wireless Controller', 'Wireless Access Point']
  	};

  	// Debug Function to log messages to console if enabled at top of script
  	function logDebug(...messages) {
  		if (debugMode) {
  			const stack = new Error().stack;
  			const caller = stack.split('\n')[2].trim().match(/at (\w+)/);
  			const callerName = caller ? caller[1] : 'Unknown';

  			const timestamp = showTimestamp ? `[${new Date().toISOString()}] ` : '';
  			console.log(`${timestamp}[${callerName}]`, ...messages);
  		}
  	}
	
	function stripIndent(strings, ...values) {
		const result = strings.reduce((acc, str, i) => acc + str + (values[i] || ''), '');
		const lines = result.split('\n');
		const minIndent = lines.filter(l => l.trim()).reduce((min, line) => Math.min(min, line.match(/^\s*/)[0].length), Infinity);
		return lines.map(line => line.slice(minIndent)).join('\n').trim();
	}

  	function processData() {
		if (hasUnsavedChanges) {
			let unsavedTables = [];
			if (tableEdited.add && !csvDownloaded.add) unsavedTables.push("Add");
			if (tableEdited.remove && !csvDownloaded.remove) unsavedTables.push("Remove");
			if (tableEdited.change && !csvDownloaded.change) unsavedTables.push("Change");
			
			const confirmMessage = stripIndent`
				There are unsaved changes in the following tables: ${unsavedTables.join(", ")}.
				Click OK to proceed and discard unsaved changes, or Cancel to go back and save your data.
			`;
			
			const confirmProcess = confirm(confirmMessage);
			if (!confirmProcess) {
				return;
			}
		}

		// Reset tracking variables
		hasUnsavedChanges = false;
		csvDownloaded = {
			add: false,
			remove: false,
			change: false
		};
		tableEdited = {
			add: false,
			remove: false,
			change: false
		};

  		clearOldData();

  		logDebug("Processing data...");

  		showProcessingOverlay('Preparing to process data...');

  		allow_blank_ip = document.getElementById('allowBlankIP').checked;

  		const input = document.getElementById('inputData').value;
  		const lines = input.trim().split('\n').filter(line => {
  			const trimmedLine = line.trim();
  			return trimmedLine !== '' && !/^\s*$/.test(trimmedLine) && trimmedLine.split('\t').some(cell => cell.trim() !== '');
  		});

  		if (lines.length === 0) {
  			logDebug("No data to process");
  			hideProcessingOverlay();
  			return;
  		}

  		showProcessingOverlay(`Processing ${lines.length} lines of data...`);

  		let headers = ['client', 'action', 'hostname', 'ip address', 'function', 'support hours', 'location', 'managed service level', 'support level', 'confidentiality class', 'platform', 'warranty expiry date', 'dtc model', 'igs device class', 'igs service tower', 'os type', 'igs backup', 'active defence', 'backup action', 'patching', 'pci role', 'pci purpose', 'notes'];
  		let dataLines = lines;

  		// Check if the first non-empty line contains headers
  		if (lines[0].toLowerCase().includes('client') || lines[0].toLowerCase().includes('hostname')) {
  			headers = lines[0].toLowerCase().split('\t').map(h => h.trim());
  			dataLines = lines.slice(1);
  		}
  		logDebug("Headers:", headers);
  		logDebug("Data lines:", dataLines);

  		const dtcModelFrom = document.getElementById('dtcModelFrom').value;
  		const dtcModelTo = document.getElementById('dtcModelTo').value;
  		const ostypeGuess = document.getElementById('ostypeGuess').checked;
  		const igsservicetowerGuess = document.getElementById('igsservicetowerGuess').checked;

  		addData = [];
  		removeData = [];
  		changeData = [];

  		// Reset counters
  		addCount = 0;
  		removeCount = 0;
  		changeCount = 0;
  		errorCount = 0;

  		dataLines.forEach((line, index) => {
  			logDebug(`Processing line ${index + 1}:`, line);
  			const values = line.split('\t');
  			logDebug("Values:", values);

  			// Skip lines that don't have enough non-empty values
  			if (values.filter(v => v.trim() !== '').length < 3) {
  				logDebug("Skipping line with insufficient data");
  				return;
  			}

  			const actionIndex = findColumnIndex(headers, ['action']);
  			logDebug("Action index:", actionIndex);
  			const action = actionIndex !== -1 && values[actionIndex] ? values[actionIndex].toLowerCase().trim() : 'add';
  			logDebug("Action:", action);

  			if (action !== 'add' && action !== 'remove' && action !== 'change') {
  				logDebug("Skipping non-add/remove/change action");
  				return;
  			}

  			const row = {};
  			requiredColumns.forEach(col => row[col] = '');

  			row['public_Name'] = (values[findColumnIndex(headers, ['hostname'])] || '').toUpperCase();
  			row['lvs.hostname'] = values[findColumnIndex(headers, ['ip address', 'ipaddress', 'ip'])] || '';
  			row['lvs.assetfunction'] = values[findColumnIndex(headers, ['function'])] || '';
  			row['lvs.supporthours'] = values[findColumnIndex(headers, ['support hours', 'supporthours'])] || '';
  			row['lvs.assetlocation'] = values[findColumnIndex(headers, ['location'])] || '';
  			row['lvs.managedservicelevel'] = values[findColumnIndex(headers, ['managed service level', 'managedservicelevel'])] || '';
  			row['lvs.supportlevel'] = values[findColumnIndex(headers, ['support level', 'supportlevel'])] || '';
  			row['lvs.confidentialityclass'] = values[findColumnIndex(headers, ['confidentiality class', 'confidentialityclass'])] || '';
  			row['lvs.deviceplatform'] = values[findColumnIndex(headers, ['platform'])] || '';
  			row['lvs.igdeviceclass'] = values[findColumnIndex(headers, ['igs device class', 'igsdeviceclass'])] || '';
  			row['lvs.igsservicetower'] = values[findColumnIndex(headers, ['igs service tower', 'igsservicetower'])] || '';
  			row['lvs.ostype'] = values[findColumnIndex(headers, ['os type', 'ostype'])] || '';
  			row['lvs.igsbackup'] = values[findColumnIndex(headers, ['igs backup', 'igsbackup'])] || '';
  			row['lvs.patching'] = values[findColumnIndex(headers, ['patching'])] || '';
  			let dtcModelIndex = findColumnIndex(headers, ['dtc model', 'dtcmodel']);
  			row['lvs.dtcmodel'] = dtcModelIndex !== -1 && values[dtcModelIndex]?.includes(dtcModelFrom) ? dtcModelTo : '';
  			row['lvs.nocdeviceclass'] = values[findColumnIndex(headers, ['managed service level', 'managedservicelevel'])] || '';

  			// Guess OS type and IGS Service Tower only for add and change actions
  			if (action === 'add' || action === 'change') {
  				// Guess OS type based on other fields
  				if (ostypeGuess && !row['lvs.ostype']) {
  					row['lvs.ostype'] = guessOSType(row);
  				}

  				// Guess IGS Service Tower based on other fields
  				if (igsservicetowerGuess && !row['lvs.igsservicetower']) {
  					row['lvs.igsservicetower'] = guessIGSServiceTower(row);
  				}
  			}

  			logDebug("Processed row:", row);
  			if (Object.values(row).some(value => value !== '')) {
  				if (action === 'add') {
  					addData.push(row);
  					addCount++;
  				} else if (action === 'remove') {
  					removeData.push(row);
  					removeCount++;
  				} else if (action === 'change') {
  					changeData.push(row);
  					changeCount++;
  				}
  			}

  			// This is contained within the displayTable function
  			//if (!row['lvs.hostname'] || !row['lvs.assetfunction']) {
  			//	row.isError = true;
  			//	errorCount++;
  			//}

  		});

  		logDebug("Add data:", addData);
  		logDebug("Remove data:", removeData);
  		logDebug("Change data:", changeData);

  		// Update the headings with the counts
  		document.getElementById('addHeading').textContent = `Add Actions (${addCount}) ${errorCount > 0 ? `| ${errorCount} error${errorCount > 1 ? 's' : ''}` : ''}`;
  		document.getElementById('removeHeading').textContent = `Remove Actions (${removeCount})`;
  		document.getElementById('changeHeading').textContent = `Change Actions (${changeCount})`;

  		setTimeout(() => {
  			displayTable('addTable', addData);
  			displayTable('removeTable', removeData);
  			displayTable('changeTable', changeData);
        
			// Update all download buttons
			updateDownloadButton('add');
			updateDownloadButton('remove');
			updateDownloadButton('change');
			
			hideProcessingOverlay();
  		}, 0);

  	}

  	function clearOldData() {
  		addData = [];
  		removeData = [];
  		changeData = [];

  		['addTable', 'removeTable', 'changeTable'].forEach(tableId => {
  			document.getElementById(tableId).innerHTML = '';
  			document.getElementById(`${tableId.replace('Table', 'ErrorSection')}`).style.display = 'none';
  		});
  	}

  	function showProcessingOverlay(status = 'Processing data...') {
  		document.getElementById('processingOverlay').style.display = 'block';
  		document.getElementById('processingStatus').textContent = status;
  	}

  	function hideProcessingOverlay() {
  		document.getElementById('processingOverlay').style.display = 'none';
  	}

  	function findColumnIndex(headers, columnNames) {
  		logDebug("Finding column index for:", columnNames);
  		logDebug("Headers:", headers);
  		for (let name of columnNames) {
  			let index = headers.findIndex(h => h.includes(name));
  			logDebug(`Checking '${name}', index:`, index);
  			if (index !== -1) return index;
  		}
  		logDebug("Column not found");
  		return -1;
  	}

  	/*
      function isValidIP(ip) {
          if (allow_blank_ip && !ip.trim()) return true; // Blank IP is valid if allowed
          if (!allow_blank_ip && !ip.trim()) return false; // Blank IP is invalid if not allowed
  		
  		// Trim whitespace and remove any characters that aren't digits or dots
  		ip = ip.trim().replace(/[^\d.]/g, '');
  		
  		//logDebug(`Validating IP after cleanup: "${ip}"`);
  		//logDebug(`IP length: ${ip.length}`);
  		//logDebug(`IP character codes: ${[...ip].map(c => c.charCodeAt(0))}`);

  		if (!ip) {
  			logDebug('IP is empty or undefined after cleanup');
  			return false;
  		}

  		const octets = ip.split('.');
  		logDebug(`Octets: ${JSON.stringify(octets)}`);

  		if (octets.length !== 4) {
  			logDebug('IP does not have exactly 4 octets');
  			return false;
  		}

  		for (let i = 0; i < octets.length; i++) {
  			const octet = octets[i];
  			//logDebug(`Validating octet ${i + 1}: "${octet}"`);
  			
  			if (!/^\d{1,3}$/.test(octet)) {
  				logDebug(`Octet ${i + 1} is not 1-3 digits`);
  				return false;
  			}

  			const num = parseInt(octet, 10);
  			if (num < 0 || num > 255 || (octet.length > 1 && octet[0] === '0')) {
  				logDebug(`Octet ${i + 1} is not between 0 and 255 or has leading zero`);
  				return false;
  			}
  		}

  		//logDebug('IP is valid');
  		return true;
  	}
  	*/

  	function isValidIP(ip) {
  		const cleanedIP = ip.trim().toLowerCase();

  		// Handle special cases for "n/a", "none", or other placeholders
  		const placeholders = ['n/a', 'none', 'not applicable', 'n/a'];

  		if (allow_blank_ip && (cleanedIP === '' || placeholders.includes(cleanedIP))) {
  			return true; // Consider these as valid if blank IPs are allowed
  		}

  		if (!allow_blank_ip && (cleanedIP === '' || placeholders.includes(cleanedIP))) {
  			return false; // Blank IPs or placeholders are invalid if not allowed
  		}

  		// Continue with standard IP validation
  		const octets = cleanedIP.split('.');
  		if (octets.length !== 4) return false;

  		for (let i = 0; i < octets.length; i++) {
  			const octet = octets[i];
  			if (!/^\d{1,3}$/.test(octet)) return false;
  			const num = parseInt(octet, 10);
  			if (num < 0 || num > 255 || (octet.length > 1 && octet[0] === '0')) return false;
  		}

  		return true;
  	}

  	function isInvalidHostname(hostname) {
  		const invalidTerms = ['n/a', 'none', 'not applicable', 'unknown', 'tbd', 'to be determined', 'null', 'undefined'];
  		return invalidTerms.includes(hostname.trim().toLowerCase()) || hostname.trim() === '';
  	}


  	function displayTable(tableId, data) {
  		logDebug('Displaying table:', tableId);
  		const table = document.getElementById(tableId);
  		table.innerHTML = '';

  		let tableErrorCount = 0;

  		// Create header row
  		const headerRow = table.insertRow();
  		headerRow.className = 'header-row';

  		// Add columns for line number, trash icon, and status
  		['#', '', 'Status', ...requiredColumns].forEach(header => {
  			const th = document.createElement('th');
  			th.textContent = header;
  			headerRow.appendChild(th);
  		});

  		// Create data rows
  		data.forEach((row, rowIndex) => {
  			const tr = table.insertRow();
  			tr.id = `${tableId}-row-${rowIndex}`;

  			// Add line number cell
  			const lineNumberCell = tr.insertCell();
  			lineNumberCell.textContent = rowIndex + 1;
  			lineNumberCell.className = 'line-number';

  			// Determine if this row has errors
  			const isIPValid = isValidIP(row['lvs.hostname']);
  			const isNameValid = !isInvalidHostname(row['public_Name']);
  			const errorReasons = [];

  			if (!isIPValid && !(allow_blank_ip && row['lvs.hostname'].trim() === '')) {
  				errorReasons.push('Invalid IP Address');
  			}
  			if (!isNameValid) {
  				errorReasons.push('Invalid Hostname');
  			}

  			row.isError = errorReasons.length > 0;
  			row.errorReasons = errorReasons;

  			if (row.isError) {
  				tableErrorCount++;
  			}

  			// Add trash icon cell
  			const trashCell = tr.insertCell();
  			if (row.isError) {
  				const trashIcon = document.createElement('span');
  				trashIcon.innerHTML = '🗑️';
  				trashIcon.className = 'trash-icon';
  				trashIcon.onclick = () => removeRow(tableId, rowIndex);
  				trashCell.appendChild(trashIcon);
  			}

  			// Add status cell
  			const statusCell = tr.insertCell();
  			const statusBadge = document.createElement('span');
  			statusBadge.className = `status-badge ${row.isError ? 'status-error' : 'status-valid'}`;
  			statusBadge.textContent = row.isError ? 'Error' : 'Valid';
  			statusCell.appendChild(statusBadge);

  			// Add data cells
  			requiredColumns.forEach((key, colIndex) => {
  				const td = tr.insertCell();

  				if (tableId === 'addTable' && key in dropdownOptions) {
  					createDropdown(td, dropdownOptions[key], row[key], (value) => updateData(tableId, rowIndex, key, value));
  				} else {
  					td.contentEditable = true;
  					td.className = 'editable';

  					if (key === 'public_Name') {
  						td.classList.add('public-name');
  						if (isInvalidHostname(row[key])) {
  							td.classList.add('invalid-name');
  						}
  						td.textContent = row[key];
  					} else if (key === 'lvs.hostname') {
  						const cleanedIP = row[key].trim().replace(/[^\d.]/g, '');
  						if (!isValidIP(cleanedIP) && !(allow_blank_ip && cleanedIP === '')) {
  							td.classList.add('invalid-ip');
  						}
  						td.textContent = cleanedIP;
  						row[key] = cleanedIP; // Update the data array with the cleaned IP
  					} else {
  						td.textContent = row[key];
  					}

  					td.dataset.row = rowIndex;
  					td.dataset.col = colIndex;
  					td.addEventListener('keydown', handleCellKeyDown);
  					td.addEventListener('blur', (event) => {
  						const newValue = event.target.textContent;
  						if (newValue !== row[key]) { // Only update if the value has changed
  							logDebug('Cell value changed:', {
  								tableId,
  								rowIndex,
  								key,
  								oldValue: row[key],
  								newValue
  							});
  							updateData(tableId, rowIndex, key, newValue);
  						}
  						if (key === 'lvs.hostname') {
  							td.classList.toggle('invalid-ip', !isValidIP(newValue));
  						} else if (key === 'public_Name') {
  							td.classList.toggle('invalid-name', isInvalidHostname(newValue));
  						}
  					});

  					// Add focus event listener to move cursor to end
  					td.addEventListener('focus', function() {
  						const range = document.createRange();
  						const sel = window.getSelection();
  						range.selectNodeContents(this);
  						range.collapse(false); // false means collapse to end
  						sel.removeAllRanges();
  						sel.addRange(range);
  					});
  				}
  			});
  		});

  		// Update error section
  		updateErrorSection(tableId, data, tableErrorCount);

  		// Update the heading
  		const headingId = `${tableId.replace('Table', 'Heading')}`;
  		const heading = document.getElementById(headingId);
  		const actionType = tableId.replace('Table', '');
  		const capitalizedActionType = actionType.charAt(0).toUpperCase() + actionType.slice(1);
  		heading.textContent = `${capitalizedActionType} Actions (${data.length}) ${tableErrorCount > 0 ? `| ${tableErrorCount} error${tableErrorCount > 1 ? 's' : ''}` : ''}`;

		const action = tableId.replace('Table', '');
		updateDownloadButton(action);

  		logDebug('Table display completed');
  	}

  	function createErrorSection(tableId, data) {
  		const errorSection = document.createElement('div');
  		errorSection.className = 'error-section';
  		errorSection.style.display = 'none';

  		const errorTitle = document.createElement('h3');
  		errorTitle.textContent = 'Errors Detected';
  		errorSection.appendChild(errorTitle);

  		const errorList = document.createElement('div');
  		data.forEach((row, index) => {
  			if (row.isError) {
  				const errorLink = document.createElement('a');
  				errorLink.href = `#${tableId}-row-${index}`;
  				errorLink.className = 'error-link';
  				const errorMessage = `Error in Row ${index + 1}: ${row.public_Name || 'Unknown'} (${row.errorReasons.join(', ')})`;
  				errorLink.textContent = errorMessage;
  				errorList.appendChild(errorLink);
  			}
  		});
  		errorSection.appendChild(errorList);

  		const table = document.getElementById(tableId);
  		table.parentNode.insertBefore(errorSection, table);

  		// Show error section if there are errors
  		if (errorList.children.length > 0) {
  			errorSection.style.display = 'block';
  		}
  	}

  	function updateErrorSection(tableId, data, errorCount) {
  		const errorSection = document.getElementById(`${tableId.replace('Table', 'ErrorSection')}`);
  		errorSection.innerHTML = '';

  		if (errorCount > 0) {
  			const errorTitle = document.createElement('h3');
  			errorTitle.textContent = 'Errors Detected';
  			errorSection.appendChild(errorTitle);

  			const errorList = document.createElement('div');
  			data.forEach((row, index) => {
  				if (row.isError) {
  					const errorLink = document.createElement('a');
  					errorLink.href = `#${tableId}-row-${index}`;
  					errorLink.className = 'error-link';
  					errorLink.textContent = `Error in Row ${index + 1}: ${row.public_Name || 'Unknown'} (${row.errorReasons.join(', ')})`;
  					errorList.appendChild(errorLink);
  				}
  			});
  			errorSection.appendChild(errorList);
  			errorSection.style.display = 'block';
  		} else {
  			errorSection.style.display = 'none';
  		}
  	}

  	// Add this function to handle all types of changes
	function recordChange(type, tableId, rowIndex, columnKey, oldValue, newValue) {
		undoStack.push({
			type,
			tableId,
			rowIndex,
			columnKey,
			oldValue,
			newValue
		});
		if (undoStack.length > maxUndoStack) {
			undoStack.shift();
		}
		redoStack = []; // Clear redo stack when a new action is performed
		hasUnsavedChanges = true;
		const action = tableId.replace('Table', '');
		tableEdited[action] = true;
		csvDownloaded[action] = false;
		updateDownloadButton(action);
		checkAllDataSaved();
		logDebug('Change recorded:', {
			type,
			tableId,
			rowIndex,
			columnKey,
			oldValue,
			newValue
		});
		logDebug('Undo stack:', undoStack);
		logDebug('Redo stack:', redoStack);
	}

  	function removeRow(tableId, rowIndex) {
  		let data;
  		if (tableId === 'addTable') {
  			data = addData;
  		} else if (tableId === 'removeTable') {
  			data = removeData;
  		} else if (tableId === 'changeTable') {
  			data = changeData;
  		}

  		// Record the change
  		recordChange('delete', tableId, rowIndex, null, data[rowIndex], null);

  		data.splice(rowIndex, 1);
  		displayTable(tableId, data);
  	}

  	function validateRow(row) {
  		const isIPValid = isValidIP(row['lvs.hostname']);
  		const isNameValid = !isInvalidHostname(row['public_Name']);
  		const errorReasons = [];

  		if (!isIPValid && !(allow_blank_ip && row['lvs.hostname'].trim() === '')) {
  			errorReasons.push('Invalid IP Address');
  		}
  		if (!isNameValid) {
  			errorReasons.push('Invalid Hostname');
  		}

  		row.isError = errorReasons.length > 0;
  		row.errorReasons = errorReasons;
  	}

  	function updateData(tableId, rowIndex, key, value) {
  		let data;
  		if (tableId === 'addTable') {
  			data = addData;
  		} else if (tableId === 'removeTable') {
  			data = removeData;
  		} else if (tableId === 'changeTable') {
  			data = changeData;
  		}

  		// Record the change
  		recordChange('edit', tableId, rowIndex, key, data[rowIndex][key], value);

  		data[rowIndex][key] = value;

  		// Validate the updated row
  		validateRow(data[rowIndex]);

  		// Redisplay the table to reflect changes
  		displayTable(tableId, data);
  	}

	function undo() {
		logDebug('Undo function called');
		if (undoStack.length > 0) {
			const lastChange = undoStack.pop();
			redoStack.push(lastChange); // Push the undone action to the redo stack
			logDebug('Undoing last change:', lastChange);
			let data;
			if (lastChange.tableId === 'addTable') {
				data = addData;
			} else if (lastChange.tableId === 'removeTable') {
				data = removeData;
			} else if (lastChange.tableId === 'changeTable') {
				data = changeData;
			}

			if (lastChange.type === 'delete') {
				logDebug('Undoing delete operation');
				data.splice(lastChange.rowIndex, 0, lastChange.oldValue);
			} else if (lastChange.type === 'edit') {
				logDebug('Undoing edit operation');
				data[lastChange.rowIndex][lastChange.columnKey] = lastChange.oldValue;
			}

			displayTable(lastChange.tableId, data);
			logDebug('Undo completed, redisplayed table');
		} else {
			logDebug('Nothing to undo, stack is empty');
		}
	}

	function redo() {
		logDebug('Redo function called');
		if (redoStack.length > 0) {
			const lastUndoneChange = redoStack.pop();
			undoStack.push(lastUndoneChange); // Push the redone action back to the undo stack
			logDebug('Redoing last undone change:', lastUndoneChange);
			let data;
			if (lastUndoneChange.tableId === 'addTable') {
				data = addData;
			} else if (lastUndoneChange.tableId === 'removeTable') {
				data = removeData;
			} else if (lastUndoneChange.tableId === 'changeTable') {
				data = changeData;
			}

			if (lastUndoneChange.type === 'delete') {
				logDebug('Redoing delete operation');
				data.splice(lastUndoneChange.rowIndex, 1);
			} else if (lastUndoneChange.type === 'edit') {
				logDebug('Redoing edit operation');
				data[lastUndoneChange.rowIndex][lastUndoneChange.columnKey] = lastUndoneChange.newValue;
			}

			displayTable(lastUndoneChange.tableId, data);
			logDebug('Redo completed, redisplayed table');
		} else {
			logDebug('Nothing to redo, stack is empty');
		}
	}

  	function createDropdown(cell, options, initialValue, onSelect) {
  		const dropdown = document.createElement('div');
  		dropdown.className = 'dropdown';
  		const input = document.createElement('input');
  		input.type = 'text';
  		input.value = initialValue;
  		input.style.width = '100%';
  		const dropdownContent = document.createElement('div');
  		dropdownContent.className = 'dropdown-content';

  		dropdown.appendChild(input);
  		dropdown.appendChild(dropdownContent);
  		cell.appendChild(dropdown);

  		let selectedIndex = -1;
  		let isDropdownVisible = false;

  		function showDropdown() {
  			dropdownContent.style.display = 'block';
  			isDropdownVisible = true;
  			updateDropdownOptions(input.value);
  		}

  		function hideDropdown() {
  			dropdownContent.style.display = 'none';
  			isDropdownVisible = false;
  		}

  		input.addEventListener('focus', showDropdown);

  		input.addEventListener('blur', () => {
  			setTimeout(hideDropdown, 200);
  		});

  		input.addEventListener('input', () => {
  			showDropdown();
  			updateDropdownOptions(input.value);
  		});

  		input.addEventListener('keydown', (e) => {
  			const items = dropdownContent.querySelectorAll('div:not(.see-all)');
  			if (e.key === 'ArrowDown') {
  				e.preventDefault();
  				if (isDropdownVisible) {
  					selectedIndex = (selectedIndex + 1) % items.length;
  					updateSelection();
  				} else {
  					navigateToNextRow(cell);
  				}
  			} else if (e.key === 'ArrowUp') {
  				e.preventDefault();
  				if (isDropdownVisible) {
  					selectedIndex = (selectedIndex - 1 + items.length) % items.length;
  					updateSelection();
  				} else {
  					navigateToPreviousRow(cell);
  				}
  			} else if (e.key === 'Enter') {
  				e.preventDefault();
  				if (isDropdownVisible && selectedIndex !== -1 && items[selectedIndex]) {
  					const selectedOption = items[selectedIndex].textContent;
  					input.value = selectedOption;
  					onSelect(selectedOption);
  					hideDropdown();
  				} else if (e.shiftKey) {
  					navigateToPreviousRow(cell);
  				} else {
  					navigateToNextRow(cell);
  				}
  			} else if (e.key === 'Tab') {
  				hideDropdown();
  			} else if (e.key === 'Backspace' && input.value === '') {
  				showDropdown();
  			}
  		});

  		function updateSelection() {
  			const items = dropdownContent.querySelectorAll('div:not(.see-all)');
  			items.forEach((item, index) => {
  				if (index === selectedIndex) {
  					item.classList.add('selected');
  					item.scrollIntoView({
  						block: 'nearest'
  					});
  				} else {
  					item.classList.remove('selected');
  				}
  			});
  		}

  		function updateDropdownOptions(filter) {
  			dropdownContent.innerHTML = '';
  			selectedIndex = -1;

  			// Add "See All" option
  			const seeAllOption = document.createElement('div');
  			seeAllOption.textContent = 'Click to See All Options';
  			seeAllOption.className = 'see-all';
  			seeAllOption.addEventListener('mousedown', (e) => {
  				e.preventDefault(); // Prevent input blur
  				updateDropdownOptions('');
  				input.focus();
  			});
  			dropdownContent.appendChild(seeAllOption);

  			const filteredOptions = filter ?
  				options.filter(option => option.toLowerCase().includes(filter.toLowerCase())) :
  				options;

  			filteredOptions.forEach(option => {
  				const div = document.createElement('div');
  				div.textContent = option;
  				div.addEventListener('mousedown', (e) => {
  					e.preventDefault(); // Prevent input blur
  					input.value = option;
  					onSelect(option);
  					hideDropdown();
  				});
  				dropdownContent.appendChild(div);
  			});

  			// Update "See All" option text if filtered
  			if (filter && filteredOptions.length < options.length) {
  				seeAllOption.textContent = 'Narrowed Selection - Click to See All';
  			}
  		}

  		function navigateToNextRow(currentCell) {
  			const currentRow = currentCell.parentElement;
  			const nextRow = currentRow.nextElementSibling;
  			if (nextRow) {
  				const nextCell = nextRow.cells[currentCell.cellIndex];
  				if (nextCell) {
  					const nextInput = nextCell.querySelector('input') || nextCell;
  					nextInput.focus();
  				}
  			}
  		}

  		function navigateToPreviousRow(currentCell) {
  			const currentRow = currentCell.parentElement;
  			const previousRow = currentRow.previousElementSibling;
  			if (previousRow && !previousRow.classList.contains('header-row')) {
  				const previousCell = previousRow.cells[currentCell.cellIndex];
  				if (previousCell) {
  					const previousInput = previousCell.querySelector('input') || previousCell;
  					previousInput.focus();
  				}
  			}
  		}
  	}

  	function handleCellKeyDown(event) {
  		if (event.key === 'Enter') {
  			event.preventDefault();
  			const currentRow = parseInt(event.target.dataset.row);
  			const currentCol = parseInt(event.target.dataset.col);
  			const table = event.target.closest('table');
  			const nextRow = table.rows[currentRow + 2]; // +2 because of the header row
  			if (nextRow) {
  				const nextCell = nextRow.cells[currentCol];
  				if (nextCell) {
  					nextCell.focus();
  				}
  			}
  		}
  	}

	function updateDownloadButton(action) {
		const buttonId = `${action}DownloadButton`;
		const button = document.getElementById(buttonId);
		if (button) {
			let data;
			switch(action) {
				case 'add':
					data = addData;
					break;
				case 'remove':
					data = removeData;
					break;
				case 'change':
					data = changeData;
					break;
				default:
					console.error('Invalid action for updateDownloadButton');
					return;
			}

			if (data && data.length > 0) {
				if (tableEdited[action]) {
					if (csvDownloaded[action]) {
						button.style.backgroundColor = '#4CAF50'; // Green
						button.style.color = 'white';
						button.textContent = `Download ${action} CSV`;
					} else {
						button.style.backgroundColor = '#FFC107'; // Yellow
						button.style.color = 'black';
						button.textContent = `Download ${action} CSV (Unsaved Changes)`;
					}
				} else {
					// Data exists but hasn't been edited
					button.style.backgroundColor = ''; // Default background
					button.style.color = ''; // Default text color
					button.textContent = `Download ${action} CSV`;
				}
			} else {
				// Reset to default state if there's no data
				button.style.backgroundColor = ''; // Default background
				button.style.color = ''; // Default text color
				button.textContent = `Download ${action} CSV`;
			}
		}
	}

	function downloadCSV(action) {
		let data;
		if (action === 'add') {
			data = addData;
		} else if (action === 'remove') {
			data = removeData;
		} else if (action === 'change') {
			data = changeData;
		} else {
			console.error('Invalid action for CSV download');
			return;
		}

		const csv = [
			requiredColumns.join(','),
			...data.map(row => requiredColumns.map(key => row[key]).join(','))
		].join('\n');

		const blob = new Blob([csv], {
			type: 'text/csv;charset=utf-8;'
		});
		const link = document.createElement("a");
		if (link.download !== undefined) {
			const url = URL.createObjectURL(blob);
			link.setAttribute("href", url);
			link.setAttribute("download", `raw_data_new.csv`);
			link.style.visibility = 'hidden';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		}

		csvDownloaded[action] = true;
		tableEdited[action] = false; // Reset the edited flag after download
		updateDownloadButton(action);
		checkAllDataSaved();
	}

	function checkAllDataSaved() {
		hasUnsavedChanges = (tableEdited.add && !csvDownloaded.add) ||
							(tableEdited.remove && !csvDownloaded.remove) ||
							(tableEdited.change && !csvDownloaded.change);
	}

  	function guessOSType(row) {
  		const deviceClass = row['lvs.igdeviceclass'].toLowerCase();
  		const assetFunction = row['lvs.assetfunction'].toLowerCase();
  		const publicName = row['public_Name'].toLowerCase();

  		if (deviceClass.includes('windows') || assetFunction.includes('windows')) {
  			return 'Windows';
  		} else if (deviceClass.includes('linux') || assetFunction.includes('linux')) {
  			return 'Linux';
  		} else if (deviceClass.includes('vmware') || assetFunction.includes('vmware') || assetFunction.includes('esxi')) {
  			return 'VMware';
  		} else if (deviceClass.includes('citrix') || assetFunction.includes('citrix')) {
  			return 'Windows'; // Assuming Citrix runs on Windows
  		} else if (deviceClass.includes('router') || deviceClass.includes('switch') || deviceClass.includes('firewall')) {
  			return 'Network';
  		} else if (deviceClass.includes('san') || deviceClass.includes('nas') || assetFunction.includes('storage')) {
  			return 'Other'; // Storage devices often have proprietary OS
  		} else if (publicName.startsWith('esx') || publicName.includes('vcenter')) {
  			return 'VMware';
  		} else if (assetFunction.includes('domain controller') || assetFunction.includes('active directory')) {
  			return 'Windows';
  		} else if (assetFunction.includes('sql server')) {
  			return 'Windows'; // Assuming SQL Server runs on Windows
  		}

  		return ''; // If we can't make a confident guess, return an empty string
  	}

  	function guessIGSServiceTower(row) {
  		const deviceClass = row['lvs.igdeviceclass'].toLowerCase();
  		const assetFunction = row['lvs.assetfunction'].toLowerCase();
  		const osType = row['lvs.ostype'].toLowerCase();

  		/*
  		// Old Classification
  		if (deviceClass.includes('citrix') || assetFunction.includes('citrix')) {
  			return 'Citrix';
  		} else if (deviceClass.includes('sql') || assetFunction.includes('database')) {
  			return 'Database';
  		} else if (assetFunction.includes('exchange') || assetFunction.includes('mail')) {
  			return 'Messaging';
  		} else if (deviceClass.includes('router') || deviceClass.includes('switch') || deviceClass.includes('firewall')) {
  			return 'Network';
  		} else if (assetFunction.includes('voice') || assetFunction.includes('voip')) {
  			return 'Network Voice';
  		} else if (deviceClass.includes('san') || deviceClass.includes('nas') || assetFunction.includes('storage') || assetFunction.includes('backup')) {
  			return 'Storage & Backup';
  		} else if (deviceClass.includes('vmware') || assetFunction.includes('vmware') || assetFunction.includes('esxi') || assetFunction.includes('hypervisor')) {
  			return 'Virtualization';
  		} else if (osType === 'windows' || deviceClass.includes('windows')) {
  			return 'Windows';
  		} else if (osType === 'linux' || deviceClass.includes('linux')) {
  			return 'Linux';
  		} else if (deviceClass.includes('noc') || assetFunction.includes('monitoring')) {
  			return 'NOC';
  		} else if (assetFunction.includes('domain controller') || assetFunction.includes('active directory') || assetFunction.includes('file server')) {
  			return 'Internal Systems';
  		}
  		*/

  		if (deviceClass.includes('citrix') || assetFunction.includes('citrix')) {
  			return 'Citrix';
  		} else if (deviceClass.includes('router') || deviceClass.includes('switch') || deviceClass.includes('firewall')) {
  			return 'Network';
  		} else if (assetFunction.includes('voice') || assetFunction.includes('voip') || assetFunction.includes('cce') || assetFunction.includes('call routing') || assetFunction.includes('cisco communications')) {
  			return 'Network Voice';
  		} else if (deviceClass.includes('sql') || assetFunction.includes('database')) {
  			return 'Database';
  		} else if (assetFunction.includes('exchange') || assetFunction.includes('mail')) {
  			return 'Messaging';
  		} else if (assetFunction.includes('cloud') || deviceClass.includes('cloud')) {
  			return 'Cloud';
  		} else if (deviceClass.includes('san') || deviceClass.includes('nas') || assetFunction.includes('storage') || assetFunction.includes('backup')) {
  			return 'Storage & Backup';
  		} else if (deviceClass.includes('noc') || assetFunction.includes('monitoring')) {
  			return 'NOC';
  		} else if (osType === 'windows' || osType === 'linux' || osType.includes('unix') ||
  			deviceClass.includes('windows') || deviceClass.includes('linux') || deviceClass.includes('unix') ||
  			deviceClass.includes('vmware') || assetFunction.includes('vmware') || assetFunction.includes('esxi') ||
  			assetFunction.includes('hypervisor') || assetFunction.includes('server')) {
  			return 'Server';
  		}

  		return ''; // If we can't make a confident guess, return an empty string
  	}

  	// Version checking functionality
  	const currentVersion = document.getElementById('versionInfo').dataset.version;

  	// Update version display in the header
  	const versionDisplay = document.getElementById('versionDisplay');
  	versionDisplay.textContent = `v${currentVersion}`;

  	// Append the changelog tooltip to the version display
  	const changelogTooltip = document.getElementById('changelogTooltip');
  	versionDisplay.appendChild(changelogTooltip);

  	function checkForUpdates() {
  		fetch('https://zvrtmzdkh4rptywwf6.github.io/index.html?_=' + new Date().getTime(), {
  				cache: 'no-store'
  			})
  			.then(response => response.text())
  			.then(html => {
  				const parser = new DOMParser();
  				const doc = parser.parseFromString(html, 'text/html');
  				const latestVersion = doc.getElementById('versionInfo').dataset.version;

  				if (latestVersion !== currentVersion) {
  					const updateNotification = document.getElementById('updateNotification');
  					document.getElementById('newVersionNumber').textContent = latestVersion;
  					document.getElementById('currentVersionNumber').textContent = currentVersion;
  					updateNotification.style.display = 'block';
  				}
  			})
  			.catch(error => console.error('Error checking for updates:', error));
  	}

  	// Check for updates every 10 minutes
  	setInterval(checkForUpdates, 10 * 60 * 1000);

  	// Initial check when the page loads
  	checkForUpdates();

	function handleGlobalKeydown(e) {
		// Check for undo (Ctrl+Z)
		if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'z') {
			e.preventDefault();
			logDebug('Ctrl+Z pressed, calling undo function');
			undo();
		}
		// Check for redo (Ctrl+Shift+Z or Ctrl+Y)
		else if ((e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'z') || 
				 (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'y')) {
			e.preventDefault();
			logDebug('Ctrl+Shift+Z or Ctrl+Y pressed, calling redo function');
			redo();
		}
	}

  	// Initialize the checkbox state
  	document.addEventListener('DOMContentLoaded', function() {
  		document.getElementById('allowBlankIP').checked = allow_blank_ip;
  		logDebug('DOM content loaded, allowBlankIP set to', allow_blank_ip);

  		// Add the global keydown event listener here
  		document.addEventListener('keydown', handleGlobalKeydown);
  	});

	window.addEventListener('beforeunload', function (e) {
		if (hasUnsavedChanges) {
			e.preventDefault();
			e.returnValue = '';
		}
	});

    </script>
</body>
</html>
