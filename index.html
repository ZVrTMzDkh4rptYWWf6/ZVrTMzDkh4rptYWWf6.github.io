<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MDAC Formatter</title>
    <style>

		body { font-family: Arial, sans-serif; margin: 20px; }
		textarea { width: 100%; height: 200px; }
		button { margin: 10px 0; }
		#configPanel { margin-bottom: 20px; }

		/* Table Styles */
		.table-container {
			max-height: 700px; overflow: auto; position: relative; z-index: 1; width: 100%;
		}
		.table-wrapper { display: flex; min-width: 100%; width: max-content; }
		table { border-collapse: separate; border-spacing: 0; width: 100%; margin-bottom: 20px; }
		th, td {
			border: 1px solid #ddd; padding: 8px; white-space: nowrap;
			overflow: hidden; text-overflow: ellipsis; box-sizing: border-box;
		}
		.frozen-table, .scrollable-table { border-collapse: separate; border-spacing: 0; }
		.frozen-table {
			position: sticky; left: 0; z-index: 5; background-color: #fff;
		}
		.frozen-table::after {
			content: ''; position: absolute; top: 0; right: 0; bottom: 0; width: 2px;
			background-color: #ddd; box-shadow: 2px 0 5px rgba(0,0,0,0.1);
		}
		.scrollable-table { flex: 1; z-index: 2; min-width: max-content; }
		.frozen-table tr, .scrollable-table tr { height: 41px; }
		.frozen-table td, .scrollable-table td { height: 100%; }
		.scrollable-table th:first-child, .scrollable-table td:first-child { padding-left: 8px; }

		/* Header Styles */
		.sticky-header-l th, .sticky-header-r th {
			position: sticky; top: 0; background-color: #f8f8f8;
		}
		.sticky-header-l th { z-index: 6; }
		.sticky-header-r th { z-index: 3; }

		/* Scrollbar Styles */
		.table-container::-webkit-scrollbar { height: 12px; }
		.table-container::-webkit-scrollbar-thumb {
			background-color: #888; border-radius: 6px;
		}
		.table-container::-webkit-scrollbar-track { background-color: #f0f0f0; }

		/* Error Styles */
		.error-row, .error-row td { background-color: #ffeecc; }
		.invalid-ip, .invalid-name { background-color: #ffcccc !important; }
		.error-section {
			background-color: #FFECB3; border: 1px solid #FFC107;
			padding: 15px; margin-bottom: 15px; border-radius: 5px;
		}
		.error-section h3 { margin: 0 0 10px 0; }
		.error-link {
			display: block; color: #D32F2F; text-decoration: none;
			margin-bottom: 3px; line-height: 1.2;
		}
		.error-link:last-child { margin-bottom: 0; }
		.error-link:hover { text-decoration: underline; }

		/* Status Styles */
		.status-badge {
			font-size: 0.8em; padding: 2px 5px; border-radius: 3px; color: white;
		}
		.status-valid { background-color: #4CAF50; }
		.status-error { background-color: #F44336; }

		/* Misc Styles */
		.public-name { max-width: 200px; }
		.line-number { width: 30px; text-align: right; color: #888; padding-right: 10px; }
		.trash-icon { cursor: pointer; }
		.see-all {
			font-size: 0.8em; color: #666; font-style: italic; background-color: #e9e9e9;
		}

		/* Dropdown Styles */
		.dropdown { position: static; display: inline-block; width: 100%; }
		.dropdown-content {
			display: none; position: absolute; background-color: #f9f9f9;
			min-width: 200px; width: max-content; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
			max-height: 200px; overflow-y: auto; z-index: 9999;
		}
		.dropdown-content.visible { display: block !important; }
		.dropdown-content div {
			padding: 12px 16px; text-decoration: none; display: block;
			cursor: pointer; white-space: nowrap;
		}
		.dropdown-content div:hover, .dropdown-content div.selected { background-color: #f1f1f1; }

		/* Update Notification */
		#updateNotification {
			position: fixed; top: 10px; right: 10px; background-color: #f0f0f0;
			padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
			display: none; z-index: 999;
		}

		/* Version Display */
		#versionDisplay {
			font-size: 0.5em; vertical-align: middle; margin-left: 10px;
			cursor: pointer; position: relative; display: inline-block;
		}
		#versionDisplay:hover #changelogTooltip { display: block; }

		/* Changelog Tooltip */
		#changelogTooltip {
			position: absolute; display: none; background-color: #444; color: #fff;
			text-align: left; border-radius: 8px; padding: 15px; width: 600px;
			max-width: 90vw; top: 100%; left: 50%; transform: translateX(-19%);
			z-index: 9999; margin-top: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
			font-size: 14px; line-height: 1.4;
		}
		#changelogTooltip h3 {
			margin: 0 0 10px 0; text-align: center; font-size: 18px;
			border-bottom: 1px solid #666; padding-bottom: 5px;
		}
		#changelogTooltip ul { margin: 0; padding-left: 20px; }
		#changelogTooltip li { margin-bottom: 10px; }
		#changelogTooltip li:last-child { margin-bottom: 0; }
		#changelogTooltip::before {
			content: ''; position: absolute; top: -10px; left: 20%;
			transform: translateX(-50%); border-width: 0 10px 10px 10px;
			border-style: solid; border-color: transparent transparent #444 transparent;
		}

		/* Processing Overlay */
		#processingOverlay {
			display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
			background-color: rgba(0,0,0,0.5); z-index: 1000;
		}
		#processingBox {
			position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
			background-color: white; padding: 20px; border-radius: 5px; text-align: center;
		}

    </style>
</head>
<body>
    <h1>MDAC Formatter <span id="versionDisplay"></span></h1>
    <div id="versionInfo" data-version="1.5.2"></div>
    <div id="changelogTooltip">
        <h3>Changelog:</h3>
        <ul>
            <li>v1.5.2:<br />- James mode!</li><br />
            <li>v1.5.1:<br />- Fixed some UTF-8 related issues with certain characters.<br />- Fixed bug with data being cleared from the 'dropdown' cells where you manually entered data.</li><br />
            <li>v1.5.0:<br />- Revamped tables to lock key info columns while scrolling in addition to a sticky header.<br />- Fixed bug with Scrolling to Error line<br />- Fixed bug with any cells containing commas which would offset the rest of that line.</li><br />
			<li>v1.4.9:<br />- Slight styling tweaks.</li><br />
            <li>v1.4.8:<br />- Added sticky header on each table so you can identify what columns are what.</li><br />
            <li>v1.4.7:<br />- Added safety feature to prevent data loss when you make changes to a table and haven't downloaded the csv yet.</li><br />
            <li>v1.4.6:<br />- Added redo function (ctrl+y or ctrl+shift+z).</li><br />
            <li>v1.4.5:<br />- Improved bug with error handler.<br />- Significantly improved displaying of errors that are found with both Hostname and IP Validation.<br/>- Added enhanced undo function.</li><br />
            <li>v1.4.4:<br />- Added Changelog Display</li><br />
            <li>v1.4.3:<br />- Added version display and changelog</li><br />
            <li>v1.4.2:<br />- Improved error handling</li><br />
        </ul>
    </div>
    <div id="updateNotification" style="display: none;">
        A new version (v<span id="newVersionNumber"></span>) is available.<br /><br /><a href="javascript:location.reload(true)">Refresh</a> the page to update from v<span id="currentVersionNumber"></span>.
    </div>
    <div id="processingOverlay">
        <div id="processingBox">
            <h3>Processing MDAC</h3>
            <p id="processingStatus">Processing data...</p>
        </div>
    </div>
    <div id="configPanel">
        <label for="dtcModelFrom">DTC Model Change:</label>
        <input type="text" id="dtcModelFrom" value="DTC2022Model">
        <label for="dtcModelTo"> To:</label>
        <input type="text" id="dtcModelTo" value="2022">
        <br/><br />
		<label for="jamesMode">James Mode:</label>
		<input type="checkbox" id="jamesMode">
		<br />
        <label for="allowBlankIP">Allow empty lvs.hostname:</label>
        <input type="checkbox" id="allowBlankIP" checked>
		<br />
        <label for="igsservicetowerGuess">Guess IGS Service Tower:</label>
        <input type="checkbox" id="igsservicetowerGuess">
		<br />
        <label for="ostypeGuess">Guess OS Type:</label>
        <input type="checkbox" id="ostypeGuess">
        <br />
    </div>
    <textarea id="inputData" placeholder="Paste your MDAC data here..."></textarea>
    <button onclick="processData()">Process Data</button>
	
    <h2 id="addHeading">Add Actions</h2>
    <div id="addErrorSection" class="error-section" style="display: none;"></div>
	<div class="table-container">
		<table id="addTable">
		    <!-- Table content -->
		</table>
	</div>
    <button id="addDownloadButton" onclick="downloadCSV('add')">Download Add CSV</button>
	
    <hr />
    <h2 id="removeHeading">Remove Actions</h2>
    <div id="removeErrorSection" class="error-section" style="display: none;"></div>
	<div class="table-container">
		<table id="removeTable">
		    <!-- Table content -->
		</table>
	</div>
    <button id="removeDownloadButton" onclick="downloadCSV('remove')">Download Remove CSV</button>
	
    <hr />
    <h2 id="changeHeading">Change Actions</h2>
    <div id="changeErrorSection" class="error-section" style="display: none;"></div>
	<div class="table-container">
		<table id="changeTable">
		    <!-- Table content -->
		</table>
	</div>
    <button id="changeDownloadButton" onclick="downloadCSV('change')">Download Change CSV</button>


    <script>

	let debugMode = false; // Set this to true when you need to debug
	const showTimestamp = false; // Set to false if you don't want timestamps in logs
	
	let allow_blank_ip = true;
	
	let undoStack = [];
	let redoStack = [];
	let maxUndoStack = 100; // Maximum number of undos
	
	let addData = [];
	let removeData = [];
	let changeData = [];
	
	let addCount = 0;
	let removeCount = 0;
	let changeCount = 0;
	let errorCount = 0;

	let jamesMode = false;
	
	let hasUnsavedChanges = false;
	
	let tableEdited = {
		add: false,
		remove: false,
		change: false
	};

	let csvDownloaded = {
  		add: false,
  		remove: false,
  		change: false
	};

	const defaultColumns = ['public_Name', 'lvs.hostname', 'lvs.assetfunction', 'lvs.supporthours', 'lvs.assetlocation', 'lvs.managedservicelevel', 'lvs.supportlevel', 'lvs.confidentialityclass', 'lvs.deviceplatform', 'lvs.igsdeviceclass', 'lvs.igsservicetower', 'lvs.ostype', 'lvs.igsbackup', 'lvs.patching', 'lvs.pcirole', 'lvs.pcipurpose', 'lvs.dtcmodel', 'lvs.nocdeviceclass', 'lvs.patchgroup'];

	const jamesColumns = ['public_Name', 'lvs.allocationcentre', 'lvs.assetfunction', 'lvs.assetlocation', 'lvs.blockrules', 'lvs.confidentialityclass', 'lvs.deviceplatform', 'lvs.dtcmodel', 'lvs.igsbackup', 'lvs.igsdeviceclass', 'lvs.igsteam', 'lvs.managedassetexport', 'lvs.managedservicelevel', 'lvs.nocdeviceclass', 'lvs.ostype', 'lvs.patchgroup', 'lvs.patching', 'lvs.pcipurpose', 'lvs.pcirole', 'lvs.profitandlosscode', 'lvs.projectcode_from', 'lvs.projectcode_to', 'lvs.supporthours', 'lvs.supportlevel', 'lvs.crmname', 'lvs.crmnumber', 'lvs.sitename'];

	let requiredColumns = defaultColumns;

  	const dropdownOptions = {
  		'lvs.igsservicetower': ['Citrix', 'Cloud', 'Database', 'Internal Systems', 'Linux', 'Messaging', 'Network', 'Network Voice', 'NOC', 'Server', 'Storage & Backup', 'Virtualization', 'Windows'],
  		'lvs.ostype': ['Network', 'Windows', 'Linux', 'VMware', 'Other', 'NTAP', 'Cisco ASA', 'FortiOS', 'iLO', 'NX-OS', 'Xen'],
  		'lvs.igsdeviceclass': ['Citrix ADC', 'Linux Virtualized', 'Windows Virtualized', 'Virtual SQL Server', 'NOC Toolset', 'SOC Toolset', 'Virtual Active Directory', 'Virtual Exchange', 'Physical Host/Blade Chassis', 'Office Firewall', 'Router', 'Edge Switch', 'Core Switch', 'Wireless Controller', 'Wireless Access Point']
  	};

  	// Debug Function to log messages to console if enabled at top of script
  	function logDebug(...messages) {
  		if (debugMode) {
  			const stack = new Error().stack;
  			const caller = stack.split('\n')[2].trim().match(/at (\w+)/);
  			const callerName = caller ? caller[1] : 'Unknown';

  			const timestamp = showTimestamp ? `[${new Date().toISOString()}] ` : '';
  			console.log(`${timestamp}[${callerName}]`, ...messages);
  		}
  	}
	
	function stripIndent(strings, ...values) {
		const result = strings.reduce((acc, str, i) => acc + str + (values[i] || ''), '');
		const lines = result.split('\n');
		const minIndent = lines.filter(l => l.trim()).reduce((min, line) => Math.min(min, line.match(/^\s*/)[0].length), Infinity);
		return lines.map(line => line.slice(minIndent)).join('\n').trim();
	}

  	function processData() {
		if (hasUnsavedChanges) {
			let unsavedTables = [];
			if (tableEdited.add && !csvDownloaded.add) unsavedTables.push("Add");
			if (tableEdited.remove && !csvDownloaded.remove) unsavedTables.push("Remove");
			if (tableEdited.change && !csvDownloaded.change) unsavedTables.push("Change");
			
			const confirmMessage = stripIndent`
				There are unsaved changes in the following tables: ${unsavedTables.join(", ")}.
				Click OK to proceed and discard unsaved changes, or Cancel to go back and save your data.
			`;
			
			const confirmProcess = confirm(confirmMessage);
			if (!confirmProcess) {
				return;
			}
		}

		// Reset tracking variables
		hasUnsavedChanges = false;
		csvDownloaded = {
			add: false,
			remove: false,
			change: false
		};
		tableEdited = {
			add: false,
			remove: false,
			change: false
		};

		clearOldData();

		logDebug("Processing data...");

		showProcessingOverlay('Preparing to process data...');

  		allow_blank_ip = document.getElementById('allowBlankIP').checked;

		const input = document.getElementById('inputData').value;
		const lines = input.trim().split('\n').filter(line => {
			const trimmedLine = line.trim();
			return trimmedLine !== '' && !/^\s*$/.test(trimmedLine) && trimmedLine.split('\t').some(cell => cell.trim() !== '');
		});

		if (lines.length === 0) {
			logDebug("No data to process");
			hideProcessingOverlay();
			return;
		}

		showProcessingOverlay(`Processing ${lines.length} lines of data...`);

  		let headers = ['client', 'action', 'hostname', 'ip address', 'function', 'support hours', 'location', 'managed service level', 'support level', 'confidentiality class', 'platform', 'warranty expiry date', 'dtc model', 'igs device class', 'igs service tower', 'os type', 'igs backup', 'active defence', 'backup action', 'patching', 'pci role', 'pci purpose', 'notes'];
  		let dataLines = lines;

  		// Check if the first non-empty line contains headers
  		if (lines[0].toLowerCase().includes('client') || lines[0].toLowerCase().includes('hostname')) {
  			headers = lines[0].toLowerCase().split('\t').map(h => h.trim());
  			dataLines = lines.slice(1);
  		}
  		logDebug("Headers:", headers);
  		logDebug("Data lines:", dataLines);

  		const dtcModelFrom = document.getElementById('dtcModelFrom').value;
  		const dtcModelTo = document.getElementById('dtcModelTo').value;
  		const ostypeGuess = document.getElementById('ostypeGuess').checked;
  		const igsservicetowerGuess = document.getElementById('igsservicetowerGuess').checked;

  		addData = [];
  		removeData = [];
  		changeData = [];

  		// Reset counters
  		addCount = 0;
  		removeCount = 0;
  		changeCount = 0;
  		errorCount = 0;

  		dataLines.forEach((line, index) => {
  			logDebug(`Processing line ${index + 1}:`, line);
  			const values = line.split('\t');
  			logDebug("Values:", values);

  			// Skip lines that don't have enough non-empty values
  			if (values.filter(v => v.trim() !== '').length < 3) {
  				logDebug("Skipping line with insufficient data");
  				return;
  			}

  			const actionIndex = findColumnIndex(headers, ['action']);
  			logDebug("Action index:", actionIndex);
  			const action = actionIndex !== -1 && values[actionIndex] ? values[actionIndex].toLowerCase().trim() : 'add';
  			logDebug("Action:", action);

  			if (action !== 'add' && action !== 'remove' && action !== 'change') {
  				logDebug("Skipping non-add/remove/change action");
  				return;
  			}

  			const row = {};
  			requiredColumns.forEach(col => row[col] = '');

  			row['public_Name'] = (values[findColumnIndex(headers, ['hostname'])] || '').toUpperCase();
  			row['lvs.hostname'] = values[findColumnIndex(headers, ['ip address', 'ipaddress', 'ip'])] || '';
  			row['lvs.assetfunction'] = values[findColumnIndex(headers, ['function'])] || '';
  			row['lvs.supporthours'] = values[findColumnIndex(headers, ['support hours', 'supporthours'])] || '';
  			row['lvs.assetlocation'] = values[findColumnIndex(headers, ['location'])] || '';
  			row['lvs.managedservicelevel'] = values[findColumnIndex(headers, ['managed service level', 'managedservicelevel'])] || '';
  			row['lvs.supportlevel'] = values[findColumnIndex(headers, ['support level', 'supportlevel'])] || '';
  			row['lvs.confidentialityclass'] = values[findColumnIndex(headers, ['confidentiality class', 'confidentialityclass'])] || '';
  			row['lvs.deviceplatform'] = values[findColumnIndex(headers, ['platform'])] || '';
  			row['lvs.igsdeviceclass'] = values[findColumnIndex(headers, ['igs device class', 'igsdeviceclass'])] || '';
  			row['lvs.igsservicetower'] = values[findColumnIndex(headers, ['igs service tower', 'igsservicetower'])] || '';
  			row['lvs.ostype'] = values[findColumnIndex(headers, ['os type', 'ostype'])] || '';
  			row['lvs.igsbackup'] = values[findColumnIndex(headers, ['igs backup', 'igsbackup'])] || '';
  			row['lvs.patching'] = values[findColumnIndex(headers, ['patching'])] || '';
  			let dtcModelIndex = findColumnIndex(headers, ['dtc model', 'dtcmodel']);
  			row['lvs.dtcmodel'] = dtcModelIndex !== -1 && values[dtcModelIndex]?.includes(dtcModelFrom) ? dtcModelTo : '';
  			row['lvs.nocdeviceclass'] = values[findColumnIndex(headers, ['managed service level', 'managedservicelevel'])] || '';

  			// Guess OS type and IGS Service Tower only for add and change actions
  			if (action === 'add' || action === 'change') {
  				// Guess OS type based on other fields
  				if (ostypeGuess && !row['lvs.ostype']) {
  					row['lvs.ostype'] = guessOSType(row);
  				}

  				// Guess IGS Service Tower based on other fields
  				if (igsservicetowerGuess && !row['lvs.igsservicetower']) {
  					row['lvs.igsservicetower'] = guessIGSServiceTower(row);
  				}
  			}

  			logDebug("Processed row:", row);
  			if (Object.values(row).some(value => value !== '')) {
  				if (action === 'add') {
  					addData.push(row);
  					addCount++;
  				} else if (action === 'remove') {
  					removeData.push(row);
  					removeCount++;
  				} else if (action === 'change') {
  					changeData.push(row);
  					changeCount++;
  				}
  			}

  		});

  		logDebug("Add data:", addData);
  		logDebug("Remove data:", removeData);
  		logDebug("Change data:", changeData);

  		// Update the headings with the counts
  		document.getElementById('addHeading').textContent = `Add Actions (${addCount}) ${errorCount > 0 ? `| ${errorCount} error${errorCount > 1 ? 's' : ''}` : ''}`;
  		document.getElementById('removeHeading').textContent = `Remove Actions (${removeCount})`;
  		document.getElementById('changeHeading').textContent = `Change Actions (${changeCount})`;

		Promise.all([
			new Promise(resolve => {
				displayTable('addTable', addData);
				resolve();
			}),
			new Promise(resolve => {
				displayTable('removeTable', removeData);
				resolve();
			}),
			new Promise(resolve => {
				displayTable('changeTable', changeData);
				resolve();
			})
		]).then(() => {
			// Update all download buttons
			updateDownloadButton('add');
			updateDownloadButton('remove');
			updateDownloadButton('change');
			
			// Hide the processing overlay after all operations are complete
			hideProcessingOverlay();
			
			logDebug('All tables displayed and buttons updated');
		});

  	}

  	function clearOldData() {
  		addData = [];
  		removeData = [];
  		changeData = [];

  		['addTable', 'removeTable', 'changeTable'].forEach(tableId => {
  			document.getElementById(tableId).innerHTML = '';
  			document.getElementById(`${tableId.replace('Table', 'ErrorSection')}`).style.display = 'none';
  		});
  	}

  	function showProcessingOverlay(status = 'Processing data...') {
  		document.getElementById('processingOverlay').style.display = 'block';
  		document.getElementById('processingStatus').textContent = status;
  	}

  	function hideProcessingOverlay() {
  		document.getElementById('processingOverlay').style.display = 'none';
  	}

  	function findColumnIndex(headers, columnNames) {
  		logDebug("Finding column index for:", columnNames);
  		logDebug("Headers:", headers);
  		for (let name of columnNames) {
  			let index = headers.findIndex(h => h.includes(name));
  			logDebug(`Checking '${name}', index:`, index);
  			if (index !== -1) return index;
  		}
  		logDebug("Column not found");
  		return -1;
  	}

  	/*
      function isValidIP(ip) {
          if (allow_blank_ip && !ip.trim()) return true; // Blank IP is valid if allowed
          if (!allow_blank_ip && !ip.trim()) return false; // Blank IP is invalid if not allowed
  		
  		// Trim whitespace and remove any characters that aren't digits or dots
  		ip = ip.trim().replace(/[^\d.]/g, '');
  		
  		//logDebug(`Validating IP after cleanup: "${ip}"`);
  		//logDebug(`IP length: ${ip.length}`);
  		//logDebug(`IP character codes: ${[...ip].map(c => c.charCodeAt(0))}`);

  		if (!ip) {
  			logDebug('IP is empty or undefined after cleanup');
  			return false;
  		}

  		const octets = ip.split('.');
  		logDebug(`Octets: ${JSON.stringify(octets)}`);

  		if (octets.length !== 4) {
  			logDebug('IP does not have exactly 4 octets');
  			return false;
  		}

  		for (let i = 0; i < octets.length; i++) {
  			const octet = octets[i];
  			//logDebug(`Validating octet ${i + 1}: "${octet}"`);
  			
  			if (!/^\d{1,3}$/.test(octet)) {
  				logDebug(`Octet ${i + 1} is not 1-3 digits`);
  				return false;
  			}

  			const num = parseInt(octet, 10);
  			if (num < 0 || num > 255 || (octet.length > 1 && octet[0] === '0')) {
  				logDebug(`Octet ${i + 1} is not between 0 and 255 or has leading zero`);
  				return false;
  			}
  		}

  		//logDebug('IP is valid');
  		return true;
  	}
  	*/

  	function isValidIP(ip) {
  		const cleanedIP = ip.trim().toLowerCase();

  		// Handle special cases for "n/a", "none", or other placeholders
  		const placeholders = ['n/a', 'none', 'not applicable', 'n/a'];

  		if (allow_blank_ip && (cleanedIP === '' || placeholders.includes(cleanedIP))) {
  			return true; // Consider these as valid if blank IPs are allowed
  		}

  		if (!allow_blank_ip && (cleanedIP === '' || placeholders.includes(cleanedIP))) {
  			return false; // Blank IPs or placeholders are invalid if not allowed
  		}

  		// Continue with standard IP validation
  		const octets = cleanedIP.split('.');
  		if (octets.length !== 4) return false;

  		for (let i = 0; i < octets.length; i++) {
  			const octet = octets[i];
  			if (!/^\d{1,3}$/.test(octet)) return false;
  			const num = parseInt(octet, 10);
  			if (num < 0 || num > 255 || (octet.length > 1 && octet[0] === '0')) return false;
  		}

  		return true;
  	}

  	function isInvalidHostname(hostname) {
  		const invalidTerms = ['n/a', 'none', 'not applicable', 'unknown', 'tbd', 'to be determined', 'null', 'undefined'];
  		return invalidTerms.includes(hostname.trim().toLowerCase()) || hostname.trim() === '';
  	}

	function displayTable(tableId, data) {
	    logDebug(`Starting displayTable function for ${tableId}`);
	    const container = document.getElementById(tableId);
	    container.innerHTML = ''; // Clear existing content
	    container.className = 'table-container';
	
	    // Create wrapper for both tables
	    const wrapper = document.createElement('div');
	    wrapper.className = 'table-wrapper';
	    container.appendChild(wrapper);
	
	    // Create frozen columns table
	    const frozenTable = document.createElement('table');
	    frozenTable.className = 'data-table frozen-table';
	    wrapper.appendChild(frozenTable);
	
	    // Create scrollable columns table
	    const scrollableTable = document.createElement('table');
	    scrollableTable.className = 'data-table scrollable-table';
	    wrapper.appendChild(scrollableTable);
	
		// Create header rows
	    createTableHeader(frozenTable, jamesMode ? ['#', '', 'Status', 'public_Name'] : ['#', '', 'Status', 'public_Name', 'lvs.hostname'], true);
	    createTableHeader(scrollableTable, jamesMode ? requiredColumns.slice(1) : requiredColumns.slice(2), false);
	
	
	    // Create table bodies
	    const frozenBody = frozenTable.createTBody();
	    const scrollableBody = scrollableTable.createTBody();
	
	    let tableErrorCount = 0;
	
	    // Create data rows
	    data.forEach((row, rowIndex) => {
	        // Determine if this row has errors
	        const isIPValid = isValidIP(row['lvs.hostname']);
	        const isNameValid = !isInvalidHostname(row['public_Name']);
	        const errorReasons = [];
	
	        if (!isIPValid && !(allow_blank_ip && row['lvs.hostname'].trim() === '')) {
	            errorReasons.push('Invalid IP Address');
	        }
	        if (!isNameValid) {
	            errorReasons.push('Invalid Hostname');
	        }
	
	        row.isError = errorReasons.length > 0;
	        row.errorReasons = errorReasons;
	
	        if (row.isError) {
	            tableErrorCount++;
	        }
	
	        createTableRow(frozenBody, scrollableBody, row, rowIndex, tableId);
	    });
	
	    // Synchronize scroll
	    synchronizeScroll(frozenBody, scrollableBody);
	
	    // Update error section
	    updateErrorSection(tableId, data, tableErrorCount);
	
	    // Update the heading
	    //updateTableHeading(tableId, data, tableErrorCount);
	
	    const action = tableId.replace('Table', '');
	    updateDownloadButton(action);
	
	    logDebug(`Finished displayTable function for ${tableId}. Error count: ${tableErrorCount}`);
	}
	
	function createTableHeader(table, headers, isLeftTable) {
	    const thead = table.createTHead();
	    const headerRow = thead.insertRow();
	    headerRow.className = isLeftTable ? 'sticky-header-l' : 'sticky-header-r';
	    headers.forEach(header => {
	        const th = document.createElement('th');
	        th.textContent = header;
	        headerRow.appendChild(th);
	    });
	}

	function createTableRow(frozenBody, scrollableBody, row, rowIndex, tableId) {
	    const frozenRow = frozenBody.insertRow();
	    const scrollableRow = scrollableBody.insertRow();
	    
	    frozenRow.id = `${tableId}-row-${rowIndex}-frozen`;
	    scrollableRow.id = `${tableId}-row-${rowIndex}-scrollable`;
	
	    if (row.isError) {
	        frozenRow.classList.add('error-row');
	        scrollableRow.classList.add('error-row');
	    }
	
	    // Add cells to frozen row
	    addLineNumberCell(frozenRow, rowIndex);
	    addTrashIconCell(frozenRow, row, rowIndex, tableId);
	    addStatusCell(frozenRow, row);
	    addEditableCell(frozenRow, row, 'public_Name', rowIndex, 3, tableId);
	    if (!jamesMode) {
	        addEditableCell(frozenRow, row, 'lvs.hostname', rowIndex, 4, tableId);
	    }
	
	    // Modify the cells added to scrollable row
	    const columnsToAdd = jamesMode ? requiredColumns.slice(1) : requiredColumns.slice(2);
	    columnsToAdd.forEach((key, colIndex) => {
	        if (tableId === 'addTable' && key in dropdownOptions) {
	            createDropdown(scrollableRow.insertCell(), dropdownOptions[key], row[key], (value) => updateData(tableId, rowIndex, key, value));
	        } else {
	            addEditableCell(scrollableRow, row, key, rowIndex, colIndex + (jamesMode ? 4 : 5), tableId);
	        }
	    });
	}

	function synchronizeScroll(frozenBody, scrollableBody) {
	    const container = scrollableBody.closest('.table-container');
	    container.addEventListener('scroll', function() {
	        frozenBody.style.transform = `translateY(-${this.scrollTop}px)`;
	    });
	}
	
	function scrollToRow(tableId, rowIndex) {
	    logDebug(`Attempting to scroll to row ${rowIndex} in table ${tableId}`);
	    
	    // Scroll the main window up by 1 pixel
	    window.scrollBy(0, -1);
	    
	    setTimeout(() => {
	        const container = document.querySelector(`#${tableId}`);
	        logDebug(`Container found: ${!!container}`);
	        
	        const frozenRow = container.querySelector(`.frozen-table tbody tr:nth-child(${rowIndex + 1})`);
	        logDebug(`Frozen row found: ${!!frozenRow}`);
	        
	        const scrollableRow = container.querySelector(`.scrollable-table tbody tr:nth-child(${rowIndex + 1})`);
	        logDebug(`Scrollable row found: ${!!scrollableRow}`);
	
	        if (frozenRow && scrollableRow && container) {
	            // Force a reflow
	            void container.offsetHeight;
	
	            // Scroll to the row
	            frozenRow.scrollIntoView({
	                behavior: 'smooth',
	                block: 'center',
	                inline: 'nearest'
	            });
	            logDebug('Scrolled to row');
	            
	            // Highlight the row temporarily
	            frozenRow.style.transition = 'background-color 0.5s';
	            scrollableRow.style.transition = 'background-color 0.5s';
	            frozenRow.style.backgroundColor = '#ffffa0';
	            scrollableRow.style.backgroundColor = '#ffffa0';
	            setTimeout(() => {
	                frozenRow.style.backgroundColor = '';
	                scrollableRow.style.backgroundColor = '';
	                setTimeout(() => {
	                    frozenRow.style.transition = '';
	                    scrollableRow.style.transition = '';
	                }, 500);
	            }, 1500);
	            logDebug('Row highlighting applied');
	        } else {
	            logDebug('Failed to find necessary elements for scrolling');
	        }
	    }, 50); // Small delay to ensure DOM is updated
	}

	function addLineNumberCell(row, rowIndex) {
		const cell = row.insertCell();
		cell.textContent = rowIndex + 1;
		cell.className = 'line-number';
	}

	function addTrashIconCell(row, dataRow, rowIndex, tableId) {
		const cell = row.insertCell();
		if (dataRow.isError) {
			const trashIcon = document.createElement('span');
			trashIcon.innerHTML = 'ðŸ—‘ï¸';
			trashIcon.className = 'trash-icon';
			trashIcon.onclick = () => removeRow(tableId, rowIndex);
			cell.appendChild(trashIcon);
		}
	}

	function addStatusCell(row, dataRow) {
		const cell = row.insertCell();
		const statusBadge = document.createElement('span');
		statusBadge.className = `status-badge ${dataRow.isError ? 'status-error' : 'status-valid'}`;
		statusBadge.textContent = dataRow.isError ? 'Error' : 'Valid';
		cell.appendChild(statusBadge);
	}

	function addEditableCell(rowElement, dataRow, key, rowIndex, colIndex, tableId) {
	    const cell = rowElement.insertCell();
	    cell.contentEditable = true;
	    cell.className = 'editable';
	
	    if (key === 'public_Name') {
	        cell.classList.add('public-name');
	        if (isInvalidHostname(dataRow[key])) {
	            cell.classList.add('invalid-name');
	        }
	        cell.textContent = dataRow[key]; // Ensure the public_Name is displayed
	    } else if (key === 'lvs.hostname') {
	        const cleanedIP = dataRow[key].trim().replace(/[^\d.]/g, '');
	        if (!isValidIP(cleanedIP) && !(allow_blank_ip && cleanedIP === '')) {
	            cell.classList.add('invalid-ip');
	        }
	        cell.textContent = cleanedIP;
	        dataRow[key] = cleanedIP; // Update the data array with the cleaned IP
	    } else {
	        cell.textContent = dataRow[key];
	    }
	
	    cell.dataset.row = rowIndex;
	    cell.dataset.col = colIndex;
	    cell.dataset.key = key;
	    cell.addEventListener('keydown', handleCellKeyDown);
	    cell.addEventListener('blur', (event) => handleCellBlur(event, tableId, rowIndex, key));
	}

	function handleCellBlur(event, tableId, rowIndex, key) {
		const newValue = event.target.textContent;
		let data;
		if (tableId === 'addTable') {
			data = addData;
		} else if (tableId === 'removeTable') {
			data = removeData;
		} else if (tableId === 'changeTable') {
			data = changeData;
		}

		if (newValue !== data[rowIndex][key]) {
			updateData(tableId, rowIndex, key, newValue);
		}
		
		if (key === 'lvs.hostname') {
			event.target.classList.toggle('invalid-ip', !isValidIP(newValue));
		} else if (key === 'public_Name') {
			event.target.classList.toggle('invalid-name', isInvalidHostname(newValue));
		}
	}


	function updateErrorSection(tableId, data, errorCount) {
		logDebug(`Updating error section for ${tableId}. Error count: ${errorCount}`);
		const errorSection = document.getElementById(`${tableId.replace('Table', 'ErrorSection')}`);
		errorSection.innerHTML = '';

		if (errorCount > 0) {
			const errorTitle = document.createElement('h3');
			errorTitle.textContent = 'Errors Detected';
			errorSection.appendChild(errorTitle);

			const errorList = document.createElement('div');
			data.forEach((row, index) => {
				if (row.isError) {
					logDebug(`Creating error link for row ${index}`);
					const errorLink = document.createElement('a');
					errorLink.href = 'javascript:void(0);';
					errorLink.className = 'error-link';
					errorLink.textContent = `Error in Row ${index + 1}: ${row.public_Name || 'Unknown'} (${row.errorReasons.join(', ')})`;
					errorLink.addEventListener('click', () => {
						logDebug(`Error link clicked for row ${index}`);
						setTimeout(() => scrollToRow(tableId, index), 0);
					});
					errorList.appendChild(errorLink);
				}
			});
			errorSection.appendChild(errorList);
			errorSection.style.display = 'block';
		} else {
			errorSection.style.display = 'none';
		}
		logDebug('Error section update completed');
	}



  	// Add this function to handle all types of changes
	function recordChange(type, tableId, rowIndex, columnKey, oldValue, newValue) {
		undoStack.push({
			type,
			tableId,
			rowIndex,
			columnKey,
			oldValue,
			newValue
		});
		if (undoStack.length > maxUndoStack) {
			undoStack.shift();
		}
		redoStack = []; // Clear redo stack when a new action is performed
		hasUnsavedChanges = true;
		const action = tableId.replace('Table', '');
		tableEdited[action] = true;
		csvDownloaded[action] = false;
		updateDownloadButton(action);
		checkAllDataSaved();
		logDebug('Change recorded:', {
			type,
			tableId,
			rowIndex,
			columnKey,
			oldValue,
			newValue
		});
		logDebug('Undo stack:', undoStack);
		logDebug('Redo stack:', redoStack);
	}

  	function removeRow(tableId, rowIndex) {
  		let data;
  		if (tableId === 'addTable') {
  			data = addData;
  		} else if (tableId === 'removeTable') {
  			data = removeData;
  		} else if (tableId === 'changeTable') {
  			data = changeData;
  		}

  		// Record the change
  		recordChange('delete', tableId, rowIndex, null, data[rowIndex], null);

  		data.splice(rowIndex, 1);
  		displayTable(tableId, data);
  	}

  	function validateRow(row) {
  		const isIPValid = isValidIP(row['lvs.hostname']);
  		const isNameValid = !isInvalidHostname(row['public_Name']);
  		const errorReasons = [];

  		if (!isIPValid && !(allow_blank_ip && row['lvs.hostname'].trim() === '')) {
  			errorReasons.push('Invalid IP Address');
  		}
  		if (!isNameValid) {
  			errorReasons.push('Invalid Hostname');
  		}

  		row.isError = errorReasons.length > 0;
  		row.errorReasons = errorReasons;
  	}

  	function updateData(tableId, rowIndex, key, value) {
  		let data;
  		if (tableId === 'addTable') {
  			data = addData;
  		} else if (tableId === 'removeTable') {
  			data = removeData;
  		} else if (tableId === 'changeTable') {
  			data = changeData;
  		}

  		// Record the change
  		recordChange('edit', tableId, rowIndex, key, data[rowIndex][key], value);

  		data[rowIndex][key] = value;

  		// Validate the updated row
  		validateRow(data[rowIndex]);

  		// Redisplay the table to reflect changes
  		displayTable(tableId, data);
  	}

	function undo() {
		logDebug('Undo function called');
		if (undoStack.length > 0) {
			const lastChange = undoStack.pop();
			redoStack.push(lastChange); // Push the undone action to the redo stack
			logDebug('Undoing last change:', lastChange);
			let data;
			if (lastChange.tableId === 'addTable') {
				data = addData;
			} else if (lastChange.tableId === 'removeTable') {
				data = removeData;
			} else if (lastChange.tableId === 'changeTable') {
				data = changeData;
			}

			if (lastChange.type === 'delete') {
				logDebug('Undoing delete operation');
				data.splice(lastChange.rowIndex, 0, lastChange.oldValue);
			} else if (lastChange.type === 'edit') {
				logDebug('Undoing edit operation');
				data[lastChange.rowIndex][lastChange.columnKey] = lastChange.oldValue;
			}

			displayTable(lastChange.tableId, data);
			logDebug('Undo completed, redisplayed table');
		} else {
			logDebug('Nothing to undo, stack is empty');
		}
	}

	function redo() {
		logDebug('Redo function called');
		if (redoStack.length > 0) {
			const lastUndoneChange = redoStack.pop();
			undoStack.push(lastUndoneChange); // Push the redone action back to the undo stack
			logDebug('Redoing last undone change:', lastUndoneChange);
			let data;
			if (lastUndoneChange.tableId === 'addTable') {
				data = addData;
			} else if (lastUndoneChange.tableId === 'removeTable') {
				data = removeData;
			} else if (lastUndoneChange.tableId === 'changeTable') {
				data = changeData;
			}

			if (lastUndoneChange.type === 'delete') {
				logDebug('Redoing delete operation');
				data.splice(lastUndoneChange.rowIndex, 1);
			} else if (lastUndoneChange.type === 'edit') {
				logDebug('Redoing edit operation');
				data[lastUndoneChange.rowIndex][lastUndoneChange.columnKey] = lastUndoneChange.newValue;
			}

			displayTable(lastUndoneChange.tableId, data);
			logDebug('Redo completed, redisplayed table');
		} else {
			logDebug('Nothing to redo, stack is empty');
		}
	}

	function createDropdown(cell, options, initialValue, onSelect) {
		const dropdown = document.createElement('div');
		dropdown.className = 'dropdown';
		const input = document.createElement('input');
		input.type = 'text';
		input.value = initialValue;
		input.style.width = '100%';
		const dropdownContent = document.createElement('div');
		dropdownContent.className = 'dropdown-content';

		dropdown.appendChild(input);
		dropdown.appendChild(dropdownContent);
		cell.appendChild(dropdown);

		let selectedIndex = -1;
		let isDropdownVisible = false;

		function positionDropdown() {
			const rect = input.getBoundingClientRect();
			const tableContainer = cell.closest('.table-container');
			const tableRect = tableContainer.getBoundingClientRect();

			logDebug('Input rect:', rect);
			logDebug('Table container rect:', tableRect);

			// Calculate position relative to the table container, accounting for scroll
			const top = rect.top - tableRect.top + tableContainer.scrollTop;
			const left = rect.left - tableRect.left + tableContainer.scrollLeft;

			dropdownContent.style.top = `${top + rect.height}px`;
			dropdownContent.style.left = `${left}px`;
			dropdownContent.style.minWidth = `${rect.width}px`;

			logDebug('Dropdown position:', {
				top: dropdownContent.style.top,
				left: dropdownContent.style.left,
				minWidth: dropdownContent.style.minWidth
			});

			// Ensure the dropdown doesn't go off-screen
			const dropdownRect = dropdownContent.getBoundingClientRect();
			const viewportWidth = window.innerWidth;
			const viewportHeight = window.innerHeight;

			if (dropdownRect.right > viewportWidth) {
				const overflowX = dropdownRect.right - viewportWidth;
				dropdownContent.style.left = `${left - overflowX}px`;
			}

			if (dropdownRect.bottom > viewportHeight) {
				dropdownContent.style.top = `${top - dropdownRect.height}px`;
			}

			// Ensure the dropdown stays within the table container
			if (parseFloat(dropdownContent.style.top) < 0) {
				dropdownContent.style.top = '0px';
			}
			if (parseFloat(dropdownContent.style.left) < 0) {
				dropdownContent.style.left = '0px';
			}
		}

		function showDropdown() {
			logDebug('Showing dropdown');
			dropdownContent.style.display = 'block';
			dropdownContent.classList.add('visible');
			isDropdownVisible = true;
			positionDropdown();
			updateDropdownOptions(input.value);
			
			// Add click event listener to document to close dropdown when clicking outside
			setTimeout(() => {
				document.addEventListener('click', closeDropdownOutside);
			}, 0);
		}

		function hideDropdown() {
			logDebug('Hiding dropdown');
			dropdownContent.style.display = 'none';
			dropdownContent.classList.remove('visible');
			isDropdownVisible = false;
			
			// Remove click event listener from document
			document.removeEventListener('click', closeDropdownOutside);
		}

		function closeDropdownOutside(event) {
			if (!dropdown.contains(event.target)) {
				hideDropdown();
			}
		}
	
		input.addEventListener('focus', (e) => {
			// Close all other dropdowns before opening this one
			document.querySelectorAll('.dropdown-content.visible').forEach(el => {
				if (el !== dropdownContent) {
					el.style.display = 'none';
					el.classList.remove('visible');
				}
			});
			showDropdown();
		});

		input.addEventListener('blur', (e) => {
			// Delayed hiding to allow for option selection
			setTimeout(() => {
				if (!dropdownContent.contains(document.activeElement)) {
					hideDropdown();
				}
			}, 200);
		});

		input.addEventListener('change', () => {
			const enteredValue = input.value;
			if (!options.includes(enteredValue)) {
				options.push(enteredValue); // Add the new value to options
			}
			onSelect(enteredValue);
		});
		
		input.addEventListener('input', () => {
			showDropdown();
			updateDropdownOptions(input.value);
		});

  		input.addEventListener('keydown', (e) => {
  			const items = dropdownContent.querySelectorAll('div:not(.see-all)');
  			if (e.key === 'ArrowDown') {
  				e.preventDefault();
  				if (isDropdownVisible) {
  					selectedIndex = (selectedIndex + 1) % items.length;
  					updateSelection();
  				} else {
  					navigateToNextRow(cell);
  				}
  			} else if (e.key === 'ArrowUp') {
  				e.preventDefault();
  				if (isDropdownVisible) {
  					selectedIndex = (selectedIndex - 1 + items.length) % items.length;
  					updateSelection();
  				} else {
  					navigateToPreviousRow(cell);
  				}
  			} else if (e.key === 'Enter') {
  				e.preventDefault();
  				if (isDropdownVisible && selectedIndex !== -1 && items[selectedIndex]) {
  					const selectedOption = items[selectedIndex].textContent;
  					input.value = selectedOption;
  					onSelect(selectedOption);
  					hideDropdown();
  				} else if (e.shiftKey) {
  					navigateToPreviousRow(cell);
  				} else {
  					navigateToNextRow(cell);
  				}
  			} else if (e.key === 'Tab') {
  				hideDropdown();
  			} else if (e.key === 'Backspace' && input.value === '') {
  				showDropdown();
  			}
  		});

  		function updateSelection() {
  			const items = dropdownContent.querySelectorAll('div:not(.see-all)');
  			items.forEach((item, index) => {
  				if (index === selectedIndex) {
  					item.classList.add('selected');
  					item.scrollIntoView({
  						block: 'nearest'
  					});
  				} else {
  					item.classList.remove('selected');
  				}
  			});
  		}

		function updateDropdownOptions(filter) {
			logDebug('Updating dropdown options with filter:', filter);
			dropdownContent.innerHTML = '';
			selectedIndex = -1;

			// Add "See All" option
			const seeAllOption = document.createElement('div');
			seeAllOption.textContent = 'Click to See All Options';
			seeAllOption.className = 'see-all';
			seeAllOption.addEventListener('mousedown', (e) => {
				e.preventDefault(); // Prevent input blur
				updateDropdownOptions('');
				input.focus();
			});
			dropdownContent.appendChild(seeAllOption);

			const filteredOptions = filter ?
				options.filter(option => option.toLowerCase().includes(filter.toLowerCase())) :
				options;

			logDebug('Filtered options:', filteredOptions);

			filteredOptions.forEach(option => {
				const div = document.createElement('div');
				div.textContent = option;
				div.addEventListener('mousedown', (e) => {
					e.preventDefault(); // Prevent input blur
					input.value = option;
					onSelect(option);
					hideDropdown();
				});
				dropdownContent.appendChild(div);
			});

			// Update "See All" option text if filtered
			if (filter && filteredOptions.length < options.length) {
				seeAllOption.textContent = 'Narrowed Selection - Click to See All';
			}

			// Reposition the dropdown after updating options
			positionDropdown();
		}

  		function navigateToNextRow(currentCell) {
  			const currentRow = currentCell.parentElement;
  			const nextRow = currentRow.nextElementSibling;
  			if (nextRow) {
  				const nextCell = nextRow.cells[currentCell.cellIndex];
  				if (nextCell) {
  					const nextInput = nextCell.querySelector('input') || nextCell;
  					nextInput.focus();
  				}
  			}
  		}

  		function navigateToPreviousRow(currentCell) {
  			const currentRow = currentCell.parentElement;
  			const previousRow = currentRow.previousElementSibling;
  			if (previousRow && !previousRow.classList.contains('header-row')) {
  				const previousCell = previousRow.cells[currentCell.cellIndex];
  				if (previousCell) {
  					const previousInput = previousCell.querySelector('input') || previousCell;
  					previousInput.focus();
  				}
  			}
  		}
		
		const tableContainer = cell.closest('.table-container');
		tableContainer.addEventListener('scroll', () => {
			if (isDropdownVisible) {
				positionDropdown();
			}
		});

		return dropdown;
	
  	}

  	function handleCellKeyDown(event) {
  		if (event.key === 'Enter') {
  			event.preventDefault();
  			const currentRow = parseInt(event.target.dataset.row);
  			const currentCol = parseInt(event.target.dataset.col);
  			const table = event.target.closest('table');
  			const nextRow = table.rows[currentRow + 2]; // +2 because of the header row
  			if (nextRow) {
  				const nextCell = nextRow.cells[currentCol];
  				if (nextCell) {
  					nextCell.focus();
  				}
  			}
  		}
  	}

	function updateDownloadButton(action) {
		const buttonId = `${action}DownloadButton`;
		const button = document.getElementById(buttonId);
		if (button) {
			let data;
			switch(action) {
				case 'add':
					data = addData;
					break;
				case 'remove':
					data = removeData;
					break;
				case 'change':
					data = changeData;
					break;
				default:
					console.error('Invalid action for updateDownloadButton');
					return;
			}

			if (data && data.length > 0) {
				if (tableEdited[action]) {
					if (csvDownloaded[action]) {
						button.style.backgroundColor = '#4CAF50'; // Green
						button.style.color = 'white';
						button.textContent = `Download ${action} CSV`;
					} else {
						button.style.backgroundColor = '#FFC107'; // Yellow
						button.style.color = 'black';
						button.textContent = `Download ${action} CSV (Unsaved Changes)`;
					}
				} else {
					// Data exists but hasn't been edited
					button.style.backgroundColor = ''; // Default background
					button.style.color = ''; // Default text color
					button.textContent = `Download ${action} CSV`;
				}
			} else {
				// Reset to default state if there's no data
				button.style.backgroundColor = ''; // Default background
				button.style.color = ''; // Default text color
				button.textContent = `Download ${action} CSV`;
			}
		}
	}

	function checkAllDataSaved() {
		hasUnsavedChanges = (tableEdited.add && !csvDownloaded.add) ||
							(tableEdited.remove && !csvDownloaded.remove) ||
							(tableEdited.change && !csvDownloaded.change);
	}

	function downloadCSV(action) {
		let data;
		if (action === 'add') {
			data = addData;
		} else if (action === 'remove') {
			data = removeData;
		} else if (action === 'change') {
			data = changeData;
		} else {
			console.error('Invalid action for CSV download');
			return;
		}

		const csv = '\ufeff' + [ // Add BOM for UTF-8
			requiredColumns.join(','), // Add column headers
			...data.map(row => 
				requiredColumns.map(key => {
					let value = row[key];
					// If the field contains a comma or special characters, wrap it in double quotes
					if (typeof value === 'string' && (value.includes(',') || /[^\u0000-\u007f]/.test(value))) {
						value = `"${value.replace(/"/g, '""')}"`; // Escape any existing quotes by doubling them
					}
					return value;
				}).join(',')
			)
		].join('\n');

		const blob = new Blob([csv], {
			type: 'text/csv;charset=utf-8;'
		});
		const link = document.createElement("a");
		if (link.download !== undefined) {
			const url = URL.createObjectURL(blob);
			link.setAttribute("href", url);
			link.setAttribute("download", `raw_data_new.csv`);
			link.style.visibility = 'hidden';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		}

		csvDownloaded[action] = true;
		tableEdited[action] = false; // Reset the edited flag after download
		updateDownloadButton(action);
		checkAllDataSaved();
	}


  	function guessOSType(row) {
  		const deviceClass = row['lvs.igsdeviceclass'].toLowerCase();
  		const assetFunction = row['lvs.assetfunction'].toLowerCase();
  		const publicName = row['public_Name'].toLowerCase();

  		if (deviceClass.includes('windows') || assetFunction.includes('windows')) {
  			return 'Windows';
  		} else if (deviceClass.includes('linux') || assetFunction.includes('linux')) {
  			return 'Linux';
  		} else if (deviceClass.includes('vmware') || assetFunction.includes('vmware') || assetFunction.includes('esxi')) {
  			return 'VMware';
  		} else if (deviceClass.includes('citrix') || assetFunction.includes('citrix')) {
  			return 'Windows'; // Assuming Citrix runs on Windows
  		} else if (deviceClass.includes('router') || deviceClass.includes('switch') || deviceClass.includes('firewall')) {
  			return 'Network';
  		} else if (deviceClass.includes('san') || deviceClass.includes('nas') || assetFunction.includes('storage')) {
  			return 'Other'; // Storage devices often have proprietary OS
  		} else if (publicName.startsWith('esx') || publicName.includes('vcenter')) {
  			return 'VMware';
  		} else if (assetFunction.includes('domain controller') || assetFunction.includes('active directory')) {
  			return 'Windows';
  		} else if (assetFunction.includes('sql server')) {
  			return 'Windows'; // Assuming SQL Server runs on Windows
  		}

  		return ''; // If we can't make a confident guess, return an empty string
  	}

  	function guessIGSServiceTower(row) {
  		const deviceClass = row['lvs.igsdeviceclass'].toLowerCase();
  		const assetFunction = row['lvs.assetfunction'].toLowerCase();
  		const osType = row['lvs.ostype'].toLowerCase();

  		/*
  		// Old Classification
  		if (deviceClass.includes('citrix') || assetFunction.includes('citrix')) {
  			return 'Citrix';
  		} else if (deviceClass.includes('sql') || assetFunction.includes('database')) {
  			return 'Database';
  		} else if (assetFunction.includes('exchange') || assetFunction.includes('mail')) {
  			return 'Messaging';
  		} else if (deviceClass.includes('router') || deviceClass.includes('switch') || deviceClass.includes('firewall')) {
  			return 'Network';
  		} else if (assetFunction.includes('voice') || assetFunction.includes('voip')) {
  			return 'Network Voice';
  		} else if (deviceClass.includes('san') || deviceClass.includes('nas') || assetFunction.includes('storage') || assetFunction.includes('backup')) {
  			return 'Storage & Backup';
  		} else if (deviceClass.includes('vmware') || assetFunction.includes('vmware') || assetFunction.includes('esxi') || assetFunction.includes('hypervisor')) {
  			return 'Virtualization';
  		} else if (osType === 'windows' || deviceClass.includes('windows')) {
  			return 'Windows';
  		} else if (osType === 'linux' || deviceClass.includes('linux')) {
  			return 'Linux';
  		} else if (deviceClass.includes('noc') || assetFunction.includes('monitoring')) {
  			return 'NOC';
  		} else if (assetFunction.includes('domain controller') || assetFunction.includes('active directory') || assetFunction.includes('file server')) {
  			return 'Internal Systems';
  		}
  		*/

  		if (deviceClass.includes('citrix') || assetFunction.includes('citrix')) {
  			return 'Citrix';
  		} else if (deviceClass.includes('router') || deviceClass.includes('switch') || deviceClass.includes('firewall')) {
  			return 'Network';
  		} else if (assetFunction.includes('voice') || assetFunction.includes('voip') || assetFunction.includes('cce') || assetFunction.includes('call routing') || assetFunction.includes('cisco communications')) {
  			return 'Network Voice';
  		} else if (deviceClass.includes('sql') || assetFunction.includes('database')) {
  			return 'Database';
  		} else if (assetFunction.includes('exchange') || assetFunction.includes('mail')) {
  			return 'Messaging';
  		} else if (assetFunction.includes('cloud') || deviceClass.includes('cloud')) {
  			return 'Cloud';
  		} else if (deviceClass.includes('san') || deviceClass.includes('nas') || assetFunction.includes('storage') || assetFunction.includes('backup')) {
  			return 'Storage & Backup';
  		} else if (deviceClass.includes('noc') || assetFunction.includes('monitoring')) {
  			return 'NOC';
  		} else if (osType === 'windows' || osType === 'linux' || osType.includes('unix') ||
  			deviceClass.includes('windows') || deviceClass.includes('linux') || deviceClass.includes('unix') ||
  			deviceClass.includes('vmware') || assetFunction.includes('vmware') || assetFunction.includes('esxi') ||
  			assetFunction.includes('hypervisor') || assetFunction.includes('server')) {
  			return 'Server';
  		}

  		return ''; // If we can't make a confident guess, return an empty string
  	}

	function setCookie(name, value, days) {
	    let expires = "";
	    if (days) {
	        const date = new Date();
	        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
	        expires = "; expires=" + date.toUTCString();
	    }
	    document.cookie = name + "=" + value + expires + "; path=/";
	}
	
	function getCookie(name) {
	    const nameEQ = name + "=";
	    const ca = document.cookie.split(';');
	    for(let i = 0; i < ca.length; i++) {
	        let c = ca[i];
	        while (c.charAt(0) === ' ') c = c.substring(1);
	        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
	    }
	    return null;
	}

  	// Version checking functionality
  	const currentVersion = document.getElementById('versionInfo').dataset.version;

  	// Update version display in the header
  	const versionDisplay = document.getElementById('versionDisplay');
  	versionDisplay.textContent = `v${currentVersion}`;

  	// Append the changelog tooltip to the version display
  	const changelogTooltip = document.getElementById('changelogTooltip');
  	versionDisplay.appendChild(changelogTooltip);

  	function checkForUpdates() {
  		fetch('https://zvrtmzdkh4rptywwf6.github.io/index.html?_=' + new Date().getTime(), {
  				cache: 'no-store'
  			})
  			.then(response => response.text())
  			.then(html => {
  				const parser = new DOMParser();
  				const doc = parser.parseFromString(html, 'text/html');
  				const latestVersion = doc.getElementById('versionInfo').dataset.version;

  				if (latestVersion !== currentVersion) {
  					const updateNotification = document.getElementById('updateNotification');
  					document.getElementById('newVersionNumber').textContent = latestVersion;
  					document.getElementById('currentVersionNumber').textContent = currentVersion;
  					updateNotification.style.display = 'block';
  				}
  			})
  			.catch(error => console.error('Error checking for updates:', error));
  	}

	function toggleJamesMode() {
		jamesMode = document.getElementById('jamesMode').checked;
		requiredColumns = jamesMode ? jamesColumns : defaultColumns;
		setCookie('jamesMode', jamesMode ? 'true' : 'false', 30);  // Store preference for 30 days
		processData();  // Reprocess and redisplay the data
	}

  	// Check for updates every 10 minutes
  	setInterval(checkForUpdates, 10 * 60 * 1000);

  	// Initial check when the page loads
  	checkForUpdates();

	function handleGlobalKeydown(e) {
		// Check for undo (Ctrl+Z)
		if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'z') {
			e.preventDefault();
			logDebug('Ctrl+Z pressed, calling undo function');
			undo();
		}
		// Check for redo (Ctrl+Shift+Z or Ctrl+Y)
		else if ((e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'z') || 
				 (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'y')) {
			e.preventDefault();
			logDebug('Ctrl+Shift+Z or Ctrl+Y pressed, calling redo function');
			redo();
		}
	}

  	// Initialize the checkbox state
	document.addEventListener('DOMContentLoaded', function() {
		document.getElementById('allowBlankIP').checked = allow_blank_ip;
		logDebug('DOM content loaded, allowBlankIP set to', allow_blank_ip);

		// Set up James Mode
		const savedJamesMode = getCookie('jamesMode');
		if (savedJamesMode !== null) {
			jamesMode = savedJamesMode === 'true';
			document.getElementById('jamesMode').checked = jamesMode;
			requiredColumns = jamesMode ? jamesColumns : defaultColumns;
		}
		document.getElementById('jamesMode').addEventListener('change', toggleJamesMode);

		// Add the global keydown event listener here
		document.addEventListener('keydown', handleGlobalKeydown);
	});


	window.addEventListener('beforeunload', function (e) {
		if (hasUnsavedChanges) {
			e.preventDefault();
			e.returnValue = '';
		}
	});

    </script>
</body>
</html>
